<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计组复习笔记</title>
    <link href="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><h2 id="1-1-计算机软硬件概念"><a href="#1-1-计算机软硬件概念" class="headerlink" title="1.1 计算机软硬件概念"></a>1.1 计算机软硬件概念</h2><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220627210639112.png" alt="image-20220627210639112"></p><h2 id="1-2-计算机体系结构中的8个伟大思想"><a href="#1-2-计算机体系结构中的8个伟大思想" class="headerlink" title="1.2 计算机体系结构中的8个伟大思想"></a>1.2 计算机体系结构中的8个伟大思想</h2><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619101700917.png" alt="image-20220619101700917"></p><p>8个伟大思想：</p><ol><li>面向摩尔定律的设计</li><li>使用抽象简化设计</li><li>加速经常性事件</li><li>通过并行提高性能</li><li>通过流水线提高性能</li><li>通过预测提高性能</li><li>存储层次</li><li>通过冗余提高可靠性</li></ol><h2 id="1-3-冯诺依曼计算机的五大部件（重点）"><a href="#1-3-冯诺依曼计算机的五大部件（重点）" class="headerlink" title="1.3 冯诺依曼计算机的五大部件（重点）"></a>1.3 冯诺依曼计算机的五大部件（重点）</h2><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619103116084.png" alt="image-20220619103116084"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619103409914.png" alt="image-20220619103409914"></p><h3 id="冯诺依曼架构计算机的特点"><a href="#冯诺依曼架构计算机的特点" class="headerlink" title="冯诺依曼架构计算机的特点"></a>冯诺依曼架构计算机的特点</h3><ul><li>计算机由五大部件组成：运算器，存储器，控制器，输入设备，输出设备</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序：指令在存储器中按顺序存放，通常是按顺序执行，特定条件下可以根据条件改变执行顺序</li><li>以运算器为中心</li></ul><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619103737510.png" alt="image-20220619103737510"></p><h2 id="1-4-冯诺依曼架构-VS-哈佛架构"><a href="#1-4-冯诺依曼架构-VS-哈佛架构" class="headerlink" title="1.4 冯诺依曼架构 VS 哈佛架构"></a>1.4 冯诺依曼架构 VS 哈佛架构</h2><p><strong>程序空间和数据空间是否是一体的</strong>? </p><ul><li><p>冯·诺依曼结构数据空间和程序空间不分开</p></li><li><p>哈佛结构数据空间和程序空间是分开的，允许同时取指和取操作数，从而大大提高了运算能力。 </p></li></ul><p>早期大多采用冯·诺依曼结构，典型代表是X86</p><p>改进型哈佛架构（数据、指令分开，且总线复用），典型代表是DSP和ARM</p><p>现在的处理器虽然外部总线上看是诺依曼结构的，但是由于内部CACHE的存在，实际上内部来看已经类似改进型哈佛结构</p><h2 id="1-5-计算机硬件的主要指标"><a href="#1-5-计算机硬件的主要指标" class="headerlink" title="1.5 计算机硬件的主要指标"></a>1.5 计算机硬件的主要指标</h2><p>时间指标：</p><ul><li>主频：CPU工作的时钟频率</li><li>时钟周期：一个时钟周期的时间（通常指处理器在固定频率下运行的时钟<ul><li><strong>主频*时钟周期=1</strong></li><li>时钟周期数：时钟周期的数量</li></ul></li><li><strong>CPI</strong>：<strong>指令平均时钟周期数</strong><ul><li>执行某个程序或程序片段时，每条指令所需的的时钟周期平均数</li><li>一段程序中所有指令的时钟周期数之和/指令条数</li><li>指令数：执行某程序所需的总指令数量</li><li><strong>程序的CPU时钟周期数=程序的指令数*CPI</strong></li></ul></li><li>MIPS、MFLOPS<ul><li>MIPS：单位时间内执行的平均指令数（每秒执行百万条指令）</li><li>MFLOPS：浮点操作次数/（执行时间*10^6）</li></ul></li><li>CPU（执行）时间：执行任务在CPU上所花费的时间<ul><li>不包括等待I/O或运行其他程序的时间。</li><li><strong>程序的CPU执行时间=程序的指令数 × CPI × 时钟周期</strong></li><li>可进一步区分为用户CPU时间和系统CPU时间（很难精确区分）<ul><li>用户CPU时间：程序本身所花的CPU时间。</li><li>系统CPU时间：为执行程序而花费在<strong>操作系统</strong>上的时间。</li></ul></li></ul></li><li>响应时间（执行时间）<ul><li>计算机完成某个任务所需的总时间</li><li>硬盘访问、内存访问、I/O活动、操作系统开销和CPU执行时间等</li></ul></li><li>吞吐率（带宽）<ul><li>单位时间内完成的任务数量</li></ul></li></ul><p>非时间指标</p><ul><li>机器字长<ul><li>CPU一次能处理数据的位数</li><li>与CPU中的寄存器位数有关，一般与内部寄存器的位数相等</li><li>目前常见的有32位和64位字长</li></ul></li><li>总线宽度<ul><li>数据总线一次能并行传送的最大信息位数</li></ul></li><li>主存容量<ul><li>是指一台计算机主存所包含的<strong>存储单元总数*存储字长</strong></li><li>存储字长指一个存储单元能存储的二进制代码的位数</li></ul></li><li>存储带宽<ul><li>指单位时间内与主存交换的二进制信息量，单位B/s</li></ul></li><li>CPU内核数</li></ul><h2 id="1-6-程序的CPU执行时间、指令数、主频、时钟周期及CPI之间的计算关系（重点）"><a href="#1-6-程序的CPU执行时间、指令数、主频、时钟周期及CPI之间的计算关系（重点）" class="headerlink" title="1.6 程序的CPU执行时间、指令数、主频、时钟周期及CPI之间的计算关系（重点）"></a>1.6 程序的CPU执行时间、指令数、主频、时钟周期及CPI之间的计算关系（重点）</h2><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619120651935.png" alt="image-20220619120651935"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619120658888.png" alt="image-20220619120658888"></p><h1 id="2-数的表示与运算"><a href="#2-数的表示与运算" class="headerlink" title="2 数的表示与运算"></a>2 数的表示与运算</h1><h1 id="3-系统总线"><a href="#3-系统总线" class="headerlink" title="3 系统总线"></a>3 系统总线</h1><h2 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h2><p>计算机系统的五大部件之间的连接方式有两种：分散连接和总线连接。 分散连接：各部件之间通过单独的连线，总线连接：将各部件连到一组公共信息传输线上。总线连接相较于分散链接，可以<strong>减少连接线的数量</strong>。</p><p>总线是连接各个部件的信息传输线</p><p>总线的两个特点：<strong>分时</strong>和<strong>共享</strong></p><p>总线遵循协议或标准，方便计算机系统集成、扩展和进化</p><p>在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。</p><p>总线的猝发传输方式：在一个总线周期内，传输存储地址连续的多个数据字的总线传输方式。</p><h2 id="3-2-总线的分类"><a href="#3-2-总线的分类" class="headerlink" title="3.2 总线的分类"></a>3.2 总线的分类</h2><p>按数据传送方式可分为并行传输总线和串行传输总线</p><p>若按总线的使用范围划分，则又有计算机（包括外设）总线、测控总线、网络通信总线等。</p><h3 id="3-2-1-片内总线"><a href="#3-2-1-片内总线" class="headerlink" title="3.2.1 片内总线"></a>3.2.1 片内总线</h3><p>片内总线是指芯片内部的总线</p><h3 id="3-2-2-系统总线"><a href="#3-2-2-系统总线" class="headerlink" title="3.2.2 系统总线"></a>3.2.2 系统总线</h3><p>系统总线是指CPU、主存、I/O （通过I/O接口）等计算机各部件之间的信息传输线</p><p>按系统传输信息的不同，系统总线又可分为三类：数据总线，地址总线和控制总线</p><h4 id="3-2-2-1-数据总线"><a href="#3-2-2-1-数据总线" class="headerlink" title="3.2.2.1 数据总线"></a>3.2.2.1 数据总线</h4><p>数据总线用来传输各功能部件之间的数据信息，它是<strong>双向</strong>传输总线，其位数与机器字长、存储字长有关</p><p>数据总线的条数称为数据总线宽度，它是衡量系统性能的一个重要参数</p><h4 id="3-2-2-2-地址总线"><a href="#3-2-2-2-地址总线" class="headerlink" title="3.2.2.2 地址总线"></a>3.2.2.2 地址总线</h4><p>地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址。</p><p>地址总线上的代码是用来指明CPU欲访问的存储单元或I/O 端口的地址，与存储地址、I/O地址有关，它是<strong>单向</strong>传输的。</p><h4 id="3-2-2-3-控制总线"><a href="#3-2-2-3-控制总线" class="headerlink" title="3.2.2.3 控制总线"></a>3.2.2.3 控制总线</h4><p>控制总线是用来发出各种控制信号的传输线</p><p>对任一控制线而言，它的传输只能是单向的</p><p>控制信号既有岀（存储器读写，总线允许，中断确认），又有入（中断请求，总线请求）</p><p>控制总线通常用于CPU发出存储器读/写命令、向CPU发出中断请求、总线请求、时钟</p><h3 id="3-2-3-通信总线"><a href="#3-2-3-通信总线" class="headerlink" title="3.2.3 通信总线"></a>3.2.3 通信总线</h3><p>通信总线用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通讯等）之间的通信。</p><p>按传输方式分为：串行通信总线、并行通信总线</p><p>按时序控制方式分为：同步通信总线、异步通信总线</p><h2 id="3-3-总线特性及性能指标"><a href="#3-3-总线特性及性能指标" class="headerlink" title="3.3 总线特性及性能指标"></a>3.3 总线特性及性能指标</h2><h3 id="3-3-1-总线特性"><a href="#3-3-1-总线特性" class="headerlink" title="3.3.1 总线特性"></a>3.3.1 总线特性</h3><p><strong>机械特性</strong>是指总线在机械连接方式上的一些性能，如几何尺寸、形状、引脚的个数（管脚数）以及排列的顺序</p><p><strong>电气特性</strong>是指总线的每一根传输线上信号的传输方向和有效的电平范围</p><p><strong>功能特性</strong>是指总线中每根传输线的功能，如地址、数据、控制</p><p><strong>时间特性</strong>是指总线中的信号的时序关系</p><h3 id="3-3-2-总线性能指标"><a href="#3-3-2-总线性能指标" class="headerlink" title="3.3.2 总线性能指标"></a>3.3.2 总线性能指标</h3><p>总线宽度：通常指数据总线的根数</p><p>标准传输率（总线带宽）：即在总线上每秒能传输的最大字节数</p><p>时钟同步/异步：同步、不同步</p><p>总线复用：地址线与数据线复用，可以减少总线中信号线的数量</p><p>信号线数：即地址总线、数据总线和控制总线三种总线数的总和</p><p>总线控制方式：包站并发工作、自动配置、仲裁方式、逻辑方式、计数方式等</p><p>其他指标：负载能力、总线时钟频率</p><h3 id="3-3-3-总线标准"><a href="#3-3-3-总线标准" class="headerlink" title="3.3.3 总线标准"></a>3.3.3 总线标准</h3><p>ISA,EISA,VESA(LV-BUS),PCI,AGP,RS-232,USB</p><p>PCI(Peripheral Component Interconnect)指的是外围部件互连标准，是目前计算机中使用最广泛的接口。PCI总线具有高性能，其自身采用33MHz和66MHz两种时钟频率，数据线为32位（可扩展为64位），最大传输速率可从132MBps(32位总线，33MHz时钟)升级到528MBps(64位总线，66MHz时钟)。</p><p>USB(Universal Seial Bus)指的是通用串行总线标准。 USB的数据传输率取决于他所使用的数据传输线的类别。对于USB1.0来说，采用普通无屏蔽的双绞线作为数据传输线，传输率可达1.5Mbps，采用带屏蔽的双绞线速度可达12Mbps。而对于USB2.0标准来说，数据传输率最高可达480Mbps，USB4.0标准已达到40GBps。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618114803519.png" alt="image-20220618114803519"></p><h2 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h2><h3 id="3-4-1-单总线结构"><a href="#3-4-1-单总线结构" class="headerlink" title="3.4.1 单总线结构"></a>3.4.1 单总线结构</h3><p>单总线结构将CPU、主存、I/O设备（通过I/O接 口）都挂在一组总线上</p><p>单总线结构不允许两个以上的部件在同一时刻向总线传输信息</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618114854885.png" alt="image-20220618114854885"></p><h3 id="3-4-2-多总线结构"><a href="#3-4-2-多总线结构" class="headerlink" title="3.4.2 多总线结构"></a>3.4.2 多总线结构</h3><p>双总线结构的特点是将速度较低的I/O设备从单总线上分离出来，形成主存总线与I/O总线分开的结构。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618114951161.png" alt="image-20220618114951161"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618115013698.png" alt="image-20220618115013698"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618115159145.png" alt="image-20220618115159145"></p><p>三总线结构包含主存总线、I/O 总线、DMA 总线</p><p>中心思想：将<strong>速率不同</strong>的I/O设备进行分类，并将他们分别连接在不同的通道上，以此进一步提升计算机系统的工作效率。 </p><p>三总线结构任一时刻只能使用一种总线。<strong>主存总线和DMA总线不能同时访问主存</strong>，I/O总线仅在CPU执行I/O指令时才会用到。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618115525812.png" alt="image-20220618115525812"></p><p>I/O设备之间一般不能直接传输数据，必须经过CPU来调度。为了某些I/O设备能更快地和主存进行数据传输，不经过CPU，引入了<strong>DMA</strong>的方式<strong>使I/O设备能直接和主存进行数据交换</strong>。</p><p>三总线结构的另一种形式：</p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618115839050.png" alt="image-20220618115839050" style="zoom:80%;"><p>由局部总线、系统总线和扩展总线组成。考虑了Cache， Cache可通过系统总线与主存交换信息。扩展总线能接各种I/O设备，解决了I/O设备的扩展问题，但这种结构会影响外部设备的工作速度。</p><p>四总线结构：即考虑了Cache，又将速率不同的I/O设备进行了分类。高速总线主要负责将高速总线中的数据传输到局部总线或者系统总线，四总线结构使得高速 I/O 设 备 更 贴 近CPU，可以大幅度提升高速 I/O设备与CPU各自的工作效率。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618120141207.png" alt="image-20220618120141207"></p><h3 id="3-4-3-总线结构举例"><a href="#3-4-3-总线结构举例" class="headerlink" title="3.4.3 总线结构举例"></a>3.4.3 总线结构举例</h3><p>（1）传统微型机总线结构</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618120208452.png" alt="image-20220618120208452"></p><p>传统微型机总线存在总线数据传输瓶颈，只有将高速、高性能的I/O设备尽量靠近CPU本身的总线，才可能消除瓶颈问题。因此，出现了VL-BUS局部总线结构。</p><p>（2）VL-BUS局部总线结构</p><p>将高速I/O设备和低速I/O设备进行分离，其中低速I/O设备通过标准总线控制器与局部总线相连。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618120345939.png" alt="image-20220618120345939"></p><p>优点：CPU与高性能I/O设备的性能都得到了充分的发挥。</p><p>缺陷：VL-BUS局部总线与CPU的关系太紧密，即VL-BUS局部总线的数据线位数受限于CPU的位数，很难支持功能更强的CPU。</p><p>（3）PCI总线结构</p><p>PCI总线通过PCI桥（包括PCI控制器和PCI加速器）与CPU系统总线相连，这种结构使得CPU总线与PCI总线相互隔离，具有更高的灵活性，可以支持更多的高速I/O设备。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618120638077.png" alt="image-20220618120638077"></p><p>多层PCI总线结构：<img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618120708867.png" alt="image-20220618120708867"></p><p>（4）采用南北桥结构的奔腾机系统总线结构</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618120855612.png" alt="image-20220618120855612"></p><h2 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h2><h3 id="3-5-1-总线判优控制"><a href="#3-5-1-总线判优控制" class="headerlink" title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h3><p>总线上所连接的各类设备，按其对总线有无控制功能可分为主设备和从设备两种。</p><p>主设备（模块）：对总线有控制权的设备</p><p>从设备（模块）：被主设备访问的设备，只能响应从主设备发来的总线命令。 </p><p>若多个主设备同时要使用总线时，就由总线控制器的判优、仲裁逻辑按一定的优先等级顺序，确定哪个主设备能使用总线。</p><p>总线判优控制可分集中式和分布式两种，前者将控制逻辑集中在一处（如在CPU中），后者将控制逻辑分散在与总线连接的各个部件或设备上。</p><p>常见的集中控制有三种优先权仲裁方式：<strong>链式査询</strong>、<strong>计数器定时查询</strong>、<strong>独立请求方式</strong>。</p><h4 id="3-5-1-1-链式查询方式"><a href="#3-5-1-1-链式查询方式" class="headerlink" title="3.5.1.1 链式查询方式"></a>3.5.1.1 链式查询方式</h4><p>在查询链中，离总线控制部件最近的设备具有最高的优先级。</p><p>链式査询的特点是：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，但对电路故障很敏感。</p><p><strong>优点</strong>：结构简单、增加或删除设备容易、判优算法简单，可靠性设计容易。</p><p><strong>缺点</strong>：对电路失效特别敏感、优先级固定，造成有些设备的总线请求很难被响应，响应速度慢。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618122531652.png" alt="image-20220618122531652"></p><h4 id="3-5-1-2-计数器定时查询方式"><a href="#3-5-1-2-计数器定时查询方式" class="headerlink" title="3.5.1.2 计数器定时查询方式"></a>3.5.1.2 计数器定时查询方式</h4><ul><li><p>设备地址线：传输设备码，每一个I/O设备都有一个独有的设备码。</p></li><li><p>计数可以从“0”开始， 此时设备的优先次序是固定的；计数也可以<strong>每次从上一次计数的终止点开始</strong>，即是一种循环方法， 此时<strong>设备使用总线的优先级相等</strong>。</p></li><li><p>当总线控制部件收到BR信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。</p></li></ul><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618122703030.png" alt="image-20220618122703030"></p><p><strong>优点</strong>：优先级设置灵活（可设置循环优先级、软件设置优先级等），可靠性高。</p><p><strong>缺点</strong>：线数多，可扩展性差，控制复杂。假设部件数为n，则控制线总数为：2+log2n</p><h4 id="3-5-1-3-独立请求方式"><a href="#3-5-1-3-独立请求方式" class="headerlink" title="3.5.1.3 独立请求方式"></a>3.5.1.3 独立请求方式</h4><p>部件需要使用总线时，发送BR请求信号，在总线控制器中排队,当总线控制器按照一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号BG(总线同意)。</p><p>独立请求方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），但控制线数量多，总线控制更复杂。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618122952855.png" alt="image-20220618122952855"></p><p><strong>优点</strong>：速度快，优先级指定方式灵活（预定方式、自适应方式、循环方式、混合方式）</p><p><strong>缺点</strong>：控制线数多</p><ul><li>三种集中式总线判优控制方式对比</li></ul><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618123303030.png" alt="image-20220618123303030"></p><h3 id="3-5-2-总线通信控制"><a href="#3-5-2-总线通信控制" class="headerlink" title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h3><p>目的：解决通信双方<strong>协调配合</strong>问题</p><p>总线传输周期:主设备和从设备之间完成一次完整可靠通讯需要的时间。总线在完成一次传输周期时，可分为四个阶段：</p><p><strong>申请分配阶段</strong>：主模块申请，总线仲裁决定</p><p><strong>寻址阶段</strong>：主模块向从模块 给出地址 和 命令</p><p><strong>传数阶段</strong>：主模块和从模块 交换数据</p><p><strong>结束阶段</strong>：主模块 撤消有关信息</p><p>解决通信双方（主模块和从模块）如何获知数据传输开始和结束，以及通信双方在数据传输过程中协调配合</p><p>总线通信控制常用的四种方式：</p><p><strong>同步通信</strong>：由 统一时标 控制数据传送</p><p><strong>异步通信</strong>：采用 应答方式，没有公共时钟标准</p><p><strong>半同步通信</strong>：同步、异步结合</p><p><strong>分离式通信</strong>：充分挖掘系统总线每个瞬间的潜力</p><h4 id="3-5-2-1-同步通信"><a href="#3-5-2-1-同步通信" class="headerlink" title="3.5.2.1 同步通信"></a>3.5.2.1 同步通信</h4><p>通信双方由统一时标控制数据传送称为同步通信</p><p>时标通常由 CPU 的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步 </p><p>读命令，其传输周期为 ：</p><ol><li>主模块发地址 ；</li><li>主模块发读命令</li><li>从模块提供数据 </li><li>主模块撤消读命令 </li></ol><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618131949642.png" alt="image-20220618131949642"></p><p>对于写命令 ， 其传输周期为 ：</p><ol><li>主模块发地址</li><li>主模块提供数据</li><li>主模块发出写命令 ， 从模块接收到命令后 ， 必须在规定时间内将数据总线上的数据写到地址总线所指明的单元中</li><li>主模块撤消写命令和数据等信号 </li></ol><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618132007274.png" alt="image-20220618132007274"></p><p>同步通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主从模块时间配合属强制性 “ 同步 ” ， 必须在限定时间内完成规定的要求 。 并且对所有从模块都用同一限时 ， 这就势必造成对各不相同速度的部件而言 ，必须按最慢速度部件来设计公共时钟 ， 严重影响总线的工作效率 ， 也给设计带来了局限性 ， 缺乏灵活性 </p><p>同步通信一般用于总线长度较短 ， 各部件存取时间比较一致的场合</p><h4 id="3-5-2-2-异步通信"><a href="#3-5-2-2-异步通信" class="headerlink" title="3.5.2.2 异步通信"></a>3.5.2.2 异步通信</h4><p>异步通信克服了同步通信的缺点 ， 允许各模块速度的不一致性 ， 给设计者充分的灵活性和选择余地 。 它没有公共的时钟标准 ， 不要求所有部件严格的统一动作时间 ， 而是采用<strong>应答方式</strong>(又称<strong>握手方式</strong> )来完成数据通信 ， 即当主模块发出请求(Request) 信号时 ， 一直等待从模块反馈回来”响应” ( Acknowledge) 信号后 ， 才开始通信 。 <em>当然 ，这就要求主从模块之间增加两条应答线(即握手交互信号线)</em></p><p>根据应答方式的不同，异步通信方式可分为<strong>不互锁</strong> 、 <strong>半互锁</strong>和<strong>全互锁</strong>三种类型。<img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618132538502.png" alt="image-20220618132538502"></p><p><strong>不互锁方式</strong>：</p><ul><li>主设备发出请求信号后，不需要等待接收到从设备的回答信号，而是经过一段时间，便撤销其请求信号。</li><li>从设备接收到请求信号后，在条件允许时发出回答信号，并且经过一段时间（这段时间的设置对于不同的从设备是不同的），自动撤销回答信号。</li><li>例如，CPU从主存中读信息就使用的是不互锁方式，CPU先后给出地址信号和读命令（请求信号）。主存接收到请求信号后，在条件允许时，将相应的数据输出到数据线上（回答信号），在维持一段时间后自动撤销。</li><li>不互锁方式主要用在单机不同设备之间的通信中。</li></ul><p><strong>半互锁方式：</strong></p><ul><li>主设备发出请求信号，必须等待接收到从设备的回答信号后再撤销请求信号，存在互锁关系。</li><li>从设备接收到请求信号后发出回答信号，并且经过一段时间后自动撤销回答信号，不存在互锁关系。 </li><li>这种方式对于主设备存在互锁关系，对于从设备不存在互锁关系，因此称为半互锁方式。</li><li>例如，在多机系统中，当某个CPU需要访问共享存储器时，首先向共享存储器发出访存命令（请求信号）。然后需要等到存储器响应当前CPU的访存命令（回答信号），将当前CPU需要的数据返回后，CPU才能继续执行下一步操作。</li></ul><p><strong>全互锁方式</strong>：</p><ul><li>主设备发出请求信号，必须等待接收到从设备的回答信号后再撤销请求信号，存在互锁关系。</li><li>从设备接收到请求信号后发出回答信号，必须等待获知到主模块请求信号已经撤销后，再撤销回答信号，也存在互锁关系。 </li><li>由于主设备和从设备双方都存在互锁关系，因此称为全互锁方式。</li><li>全互锁方式主要应用于网络通信中，最典型的应用就是TCP的“三次握手”协议。 </li></ul><h4 id="3-5-2-3-半同步通信"><a href="#3-5-2-3-半同步通信" class="headerlink" title="3.5.2.3 半同步通信"></a>3.5.2.3 半同步通信</h4><p>半同步通信集同步与异步通信之优点 ， 既保留了同步通信的基本特点 ， 如所有的地址、命令 、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别。同时又像异步通信那样，允许不同速度的模块和谐地工作，为此增设了一条 “ 等待 ” (WAIT) 响应信号线 。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618133632659.png" alt="image-20220618133632659"></p><h4 id="3-5-2-4-分离式通信"><a href="#3-5-2-4-分离式通信" class="headerlink" title="3.5.2.4 分离式通信"></a>3.5.2.4 分离式通信</h4><p>哈深版本：</p><p>总线传输周期：</p><ul><li>子周期1：主模块申请占用总线，用完后放弃总线使用权</li><li>子周期2：从模块申请占用总线，将信息送至总线</li></ul><p>分离式通信的特点：</p><ul><li>各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲</li><li><strong>充分提高了总线的利用率</strong></li></ul><p>本部版本：</p><p>分离式通信的特点是 ： ①各模块欲占用总线使用权都必须提出申请 ； ②在得到总线使用权后 ， 主模块在限定的时间内向对方传送信息 ， 采用同步方式传送 ， 不再等待对方的回答信号 ； ③各模块在准备数据传送的过程中都不占用总线 ， 使总线可接受其他模块的请求 ； ④总线被占用时都在作有效工作 ， 或者通过它发命令 ，或者通过它传送数据 ， 不存在空闲等待时间 ， 最充分地发挥了总线的有效占用 ，从而实现了总线为多个主从模块间进行信息交叉重叠并行式传送 。</p><h1 id="4-存储器"><a href="#4-存储器" class="headerlink" title="4 存储器"></a>4 存储器</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-存储器分类"><a href="#4-1-1-存储器分类" class="headerlink" title="4.1.1 存储器分类"></a>4.1.1 存储器分类</h3><h4 id="4-1-1-1-按存储介质分类"><a href="#4-1-1-1-按存储介质分类" class="headerlink" title="4.1.1.1 按存储介质分类"></a>4.1.1.1 按存储介质分类</h4><p>按存储介质分类：半导体存储器、磁表面存储器、磁芯存储器、光盘存储器</p><p>易失性是指数据保存的环境如果不能满足某种条件，就确定会丢失</p><p>易失性存储器：半导体存储器</p><p>非易失性存储器：磁表面存储器、磁芯存储器、光盘存储器</p><h4 id="4-1-1-2-按存取方式分类"><a href="#4-1-1-2-按存取方式分类" class="headerlink" title="4.1.1.2 按存取方式分类"></a>4.1.1.2 按存取方式分类</h4><p>按存取方式分类：</p><p>随机访问（存取时间与物理地址无关）：随机存储器 RAM（可读可写）、只读存储器 ROM（只读）</p><p>串行访问（存取时间与物理地址有关）：顺序存取存储器（磁带）、直接存储存储器（磁盘）</p><h4 id="4-1-1-3-按在计算机中的作用分类"><a href="#4-1-1-3-按在计算机中的作用分类" class="headerlink" title="4.1.1.3 按在计算机中的作用分类"></a>4.1.1.3 按在计算机中的作用分类</h4><p>按在计算机中的作用分类：</p><p>主存储器：RAM(SRAM/DRAM)、ROM(MROM/PROM/EPROM/EEPROM)</p><p>Flash Memory：U盘、固态硬盘（SSD）</p><p>高速缓冲存储器（Cache）：CPU寄存器与主存之间</p><p>辅助存储器：磁盘、磁带、光盘</p><p><em>主存储器的主要特点是它可以和 CPU 直接交换信息</em></p><h3 id="4-1-2-存储器的层次结构"><a href="#4-1-2-存储器的层次结构" class="headerlink" title="4.1.2 存储器的层次结构"></a>4.1.2 存储器的层次结构</h3><p>存储器有三个主要特性：速度、容量和价格/位</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/360MoveData/Users/MARVEL/Desktop/计组复习/note_thj_202206/计算机组成原理Note.assets/image-20200313072357076.png" alt="image-20200313072357076"></p><p>存储器的层次结构主要体现在<strong>缓存一主存</strong>（速度）和<strong>主存一辅存</strong>（容量）这两个存储层次上</p><p>分级的目的是<strong>提高访存速度，扩大存储容量</strong></p><p>计算机的存储系统通常采用层次结构，在选择各层次所用的器件时，应综合考虑<strong>速度</strong>，<strong>容量</strong>，<strong>成本</strong>，<strong>密度</strong>，<strong>能耗/功耗</strong></p><p>主存储器（实地址/物理地址），虚拟存储器（虚地址/逻辑地址）</p><p><em>缓存一主存这一层次的速度接近于缓存 ， 高于主存 ；其容量和位价却接近于主存</em></p><p><em>主存一辅存这一层次 ， 从整体分析 ，廉价的辅存位价 ， 这又解决了速度 、 容量 、 成本这三者矛盾</em> </p><h2 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><h4 id="4-2-1-1-主存的基本组成"><a href="#4-2-1-1-主存的基本组成" class="headerlink" title="4.2.1.1 主存的基本组成"></a>4.2.1.1 主存的基本组成</h4><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200316015609909.png" alt="image-20200316015609909"></p><p>MAR(Memory Address Regisiter):访问数据的地址</p><p>MDR(Memory Data Regisiter):保存要被写入/读出地址单元的数据</p><p>根据 MAR 中的地址访问某个存储单元时 ， 还需经过地址译码 、 驱动等电路</p><p>读出时 ， 需经过读出放大器 ，才能将被选中单元的存储字送到 MDR 。 写入时， MDR 中的数据也必须经过写入电路才能真正写入到被选中的单元中 。</p><h4 id="4-2-1-2-主存和CPU的联系"><a href="#4-2-1-2-主存和CPU的联系" class="headerlink" title="4.2.1.2 主存和CPU的联系"></a>4.2.1.2 主存和CPU的联系</h4><p>地址总线（单向：CPU指向主存）</p><p>数据总线（双向）</p><h4 id="4-2-1-3-主存中存储单元地址的分配"><a href="#4-2-1-3-主存中存储单元地址的分配" class="headerlink" title="4.2.1.3 主存中存储单元地址的分配"></a>4.2.1.3 主存中存储单元地址的分配</h4><p>大端：低地址存放高位</p><p>小端：低地址存放低位</p><p>按字节、字（16/32bit）寻址，求存储器寻址范围？</p><p><em>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来 指出存储单元地址号的，根据该地址可读出一个存储字。</em></p><h4 id="4-2-1-4-主存的技术指标"><a href="#4-2-1-4-主存的技术指标" class="headerlink" title="4.2.1.4 主存的技术指标"></a>4.2.1.4 主存的技术指标</h4><p>（1）存储容量：存放二进制代码的总位数</p><p>（2）存储速度：</p><p>存储时间：存储器的访问时间（读出时间、写入时间）</p><p>存储周期：连续两次独立的存储器操作（读或写）所需的最小间隔时间（读周期、写周期）</p><p><em>存取时间比存取周期要短</em></p><p>（3）存储器的带宽：<strong>每秒从存储器中读出或写入的二进制代码位数</strong>（单位：<strong>Bps或bps</strong>或位/秒 或 <strong>字/秒</strong>）</p><p>为了增加存储器带宽可以采用<strong>单体多字结构</strong>和<strong>低位交叉多体并行结构</strong>。</p><h3 id="4-2-2-半导体存储芯片"><a href="#4-2-2-半导体存储芯片" class="headerlink" title="4.2.2 半导体存储芯片"></a>4.2.2 半导体存储芯片</h3><h4 id="4-2-2-1半导体存储芯片的基本结构"><a href="#4-2-2-1半导体存储芯片的基本结构" class="headerlink" title="4.2.2.1半导体存储芯片的基本结构"></a>4.2.2.1半导体存储芯片的基本结构</h4><p>半导体存储芯片内集成具有记忆功能的存储矩阵、译码驱动电路和读写电路</p><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号， </p><p>读写电路包括读出放大器和写入电路，用来完成读写操作。</p><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p><p>地址线是单向输入的</p><p>数据线是双向的</p><p>地址线和数据线的位数共同反映存储芯片的容量</p><p>芯片容量为 $ 2 ^ n \times m $ (n 为地址线数量，m 为数据线数量)</p><p>控制线主要有读/写控制线与片选线两种</p><p>读/写控制线决定芯片进行读/写操作</p><p>片选线用来选择存储芯片</p><p>$\overline{CS},\overline{CE}$分别表示芯片选择和芯片使能，上划线表示低电平有效</p><p>一根线：$\overline{WE}$表示读/写控制线，低电平写、高电平读</p><p>两根线：$\overline{OE}$低电平读，$\overline{WE}$表示低电平写</p><h4 id="4-2-2-2-半导体储存芯片的译码驱动方式"><a href="#4-2-2-2-半导体储存芯片的译码驱动方式" class="headerlink" title="4.2.2.2 半导体储存芯片的译码驱动方式"></a>4.2.2.2 半导体储存芯片的译码驱动方式</h4><p>半导体存储芯片的译码驱动方式有两种 ： <strong>线选法</strong>和<strong>重合法</strong></p><p>线选法的特点是用一根字选择线（ 字线），同时选中一个存储单元中的8位数据，<em>只适于容量不大的存储芯片</em>。</p><p>重合法用“行列”选择线来选定存储单元，<em>所需的线少</em>。</p><h3 id="4-2-3-随机存取存储器"><a href="#4-2-3-随机存取存储器" class="headerlink" title="4.2.3 随机存取存储器"></a>4.2.3 随机存取存储器</h3><h4 id="4-2-3-1-静态-RAM"><a href="#4-2-3-1-静态-RAM" class="headerlink" title="4.2.3.1 静态 RAM"></a>4.2.3.1 静态 RAM</h4><h5 id="（1）基本电路"><a href="#（1）基本电路" class="headerlink" title="（1）基本电路"></a>（1）基本电路</h5><p>使用<strong>双稳态触发器</strong>储存01</p><p>基本电路由触发器（双稳态T1~T4）、位线、行列开关（行开关T5T6，列开关T7T8：一列共用）、读写放大器（读放大器一个、写放大器两个）组成</p><p>典型芯片：Inter 2114</p><h5 id="（2）芯片电路结构及读写操作"><a href="#（2）芯片电路结构及读写操作" class="headerlink" title="（2）芯片电路结构及读写操作"></a>（2）芯片电路结构及读写操作</h5><p><em>读写操作和读写时序见课件</em></p><p>Inter 2114 如何实现 4 位读写？</p><p>将 1K * 4 位分为 64 * 64，并分为 16列 * 64行 的 4 组。用 6 位行的地址和 4 位列地址可以输出每一组的一个单元，合在一起就算 4 位。</p><h5 id="（3）读写时序"><a href="#（3）读写时序" class="headerlink" title="（3）读写时序"></a>（3）读写时序</h5><p>SRAM（2114）读时序总结：</p><ul><li>当地址有效后经过𝑡𝐴时间（读时间），且当片选有效后经过𝑡𝑐𝑜时间，输出数据才能稳定。因此，我们必须在输入地址有效后的(𝑡𝐴 − 𝑡𝑐𝑜)时间内给出片选有效信号，否则无法从存储芯片中读出正确的数据。</li><li>当片选地址失效后，从片选失效到输出数据变为高阻态（输出数据失效），之间需要经过𝑡𝑂𝑇𝐷的时间。这样当地址失效后，数据仍能在数据线上维持𝑡𝑂𝐻𝐴的时间，这样做的目的是为了保证读取数据的可靠性，避免输入地址失效的瞬间，读取的数据就失效。</li></ul><p>SRAM（2114）写时序总结：</p><ul><li>当输入地址有效后，需要滞后一段时间𝑡𝐴𝑊，片选信号𝐶𝑆和写入使能信号𝑊𝐸才有效。这是因为在需要写入的数据有效前，RAM的输入输出数据线上可能存在之前读取的数据。可以避免写入错误的数据。</li><li>在写入使能信号𝑊𝐸失效后，输入地址还必须保持一段时间𝑡𝑊𝑅，称为写恢复时间，这是为了保证数据能够可靠地写入。</li><li>需要写入的数据𝐷𝐼𝑁，必须在片选信号和写入使能信号失效前的𝑡𝐷𝑊时间内，在数据线上稳定，并且在片选信号和写入使能信号失效后仍要维持一段时间𝑡𝐷𝐻,这样做也是为了保证数据可靠地写入。</li></ul><h4 id="4-2-3-2-动态-RAM"><a href="#4-2-3-2-动态-RAM" class="headerlink" title="4.2.3.2 动态 RAM"></a>4.2.3.2 动态 RAM</h4><h5 id="（1）基本电路-1"><a href="#（1）基本电路-1" class="headerlink" title="（1）基本电路"></a>（1）基本电路</h5><p>使用<strong>电容</strong>储存01（电容存储电荷）</p><p>常见的DRAM 基本单元电路有<strong>三管式</strong>和<strong>单管式</strong>两种</p><p>三管式<strong>读出与原存信息相反，写入与输入信息相同</strong></p><p>单管式<strong>读出时数据线有电流为“1”</strong>，（<em>会泄放电荷，必须再生</em>），<strong>写入时Cs充电为“1”，放电为“0”</strong></p><h5 id="（2）芯片电路结构及读写操作-1"><a href="#（2）芯片电路结构及读写操作-1" class="headerlink" title="（2）芯片电路结构及读写操作"></a>（2）芯片电路结构及读写操作</h5><p>典型芯片：Inter 1103（三管）、Inter 4116（单管）</p><p>Intel 1103三管动态RAM中，每列都有一个刷新放大器（用于形成再生信息）和预充电管。</p><p><em>Intel 4116单管动态RAM容量为</em>16K*<em>1位，但只有7位地址线，通过缓存器先后读取行地址和列地址。</em></p><p><em>4116动态RAM芯片中的读放大器的工作原理像一个撬撬板电路，其左右两侧电平相反。</em></p><h5 id="（3）读写时序-1"><a href="#（3）读写时序-1" class="headerlink" title="（3）读写时序"></a>（3）读写时序</h5><p>行列地址分开传送</p><h5 id="（4）DRAM的刷新"><a href="#（4）DRAM的刷新" class="headerlink" title="（4）DRAM的刷新"></a>（4）DRAM的刷新</h5><p><em>电容上的电荷一般只能维持 1~2ms，信息会自动消失，必须在 2ms 内对其所有存储单元恢复一次原状态，这个过程叫再生或刷新</em></p><p>刷新是一种再生过程：先将原存信息读出，再由刷新放大器形成原信息并重新写入</p><p>DRAM刷新的原因：DRAM以电容存储电荷的方式存储01，电容易漏电，长期得不到访问的存储单元的原信息会慢慢消失</p><p>动态RAM的刷新只与<strong>行地址</strong>有关，该地址由<strong>刷新地址计数器</strong>给出</p><p>动态RAM刷新的三种方法：<strong>集中刷新</strong>、<strong>分散刷新</strong>、<strong>异步刷新</strong></p><ul><li>集中刷新是在规定的一个刷新周期内（刷新周期一般为2ms） ， 对全部存储单元集中一段时间逐行进行刷新。   集中刷新的缺点在于出现了访存 “ 死区 ”，必须停止读 / 写操作。   集中刷新死区时间=存取周期*行数，死时间率=死区/刷新周期</li><li>分散刷新是指对每行存储单元的刷新分散到每个读 / 写周期内完成 。 把存取周期分成两段 ， 前半段用来读写或维持 ， 后半段用来刷新。（缺点是产生过度刷新，读写周期变长了）</li><li>异步刷新是集中刷新与分散刷新相结合的方式，每隔一段时间（一个刷新周期）刷新一行，在一个刷新周期内保证全部行被刷新。（<em>将刷新安排在指令译码阶段，不会出现“死区”，从根本上提高了整机的工作效率</em>）</li></ul><h4 id="4-2-3-3-动态-RAM-与静态-RAM-的比较"><a href="#4-2-3-3-动态-RAM-与静态-RAM-的比较" class="headerlink" title="4.2.3.3 动态 RAM 与静态 RAM 的比较"></a>4.2.3.3 动态 RAM 与静态 RAM 的比较</h4><table><thead><tr><th></th><th>DRAM</th><th>SRAM</th></tr></thead><tbody><tr><td>存储原理</td><td>电容</td><td>触发器</td></tr><tr><td>集成度</td><td>高</td><td>低</td></tr><tr><td>芯片引脚</td><td>少</td><td>多</td></tr><tr><td>功耗</td><td>小</td><td>大</td></tr><tr><td>价格</td><td>低</td><td>高</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr><tr><td>刷新</td><td>有</td><td>无</td></tr></tbody></table><p>通常DRAM用于主存，SRAM用于缓存</p><p>DRAM行、列地址可以分别进行传送，地址线可以减少为原来的一半，芯片引脚数减少。</p><h3 id="4-2-4-只读存储器"><a href="#4-2-4-只读存储器" class="headerlink" title="4.2.4 只读存储器"></a>4.2.4 只读存储器</h3><h4 id="4-2-4-1-掩膜-ROM（MROM）"><a href="#4-2-4-1-掩膜-ROM（MROM）" class="headerlink" title="4.2.4.1 掩膜 ROM（MROM）"></a>4.2.4.1 掩膜 ROM（MROM）</h4><p>用行 、 列交叉处是否有耦合元件 MOS 管 ， 便可区分原存 “ 1 ” 还是存 “ 0 ” 。（行列选择线交叉处有MOS管为“1”，无MOS管为“0”）</p><p>用户无法改变原始状态（用户不能修改）。</p><h4 id="4-2-4-2-PROM"><a href="#4-2-4-2-PROM" class="headerlink" title="4.2.4.2 PROM"></a>4.2.4.2 PROM</h4><p>PROM 是可以实现<strong>一次性编程</strong>的只读存储器</p><p>（熔丝断为0，熔丝未断为1）</p><h4 id="4-2-4-3-EPROM"><a href="#4-2-4-3-EPROM" class="headerlink" title="4.2.4.3 EPROM"></a>4.2.4.3 EPROM</h4><p>EPROM 是一种可擦洗可<strong>多次性编程</strong>的只读存储器</p><p>紫外线照射可驱散浮动栅 </p><h4 id="4-2-4-4-EEPROM"><a href="#4-2-4-4-EEPROM" class="headerlink" title="4.2.4.4 EEPROM"></a>4.2.4.4 EEPROM</h4><p>电可擦写，可<strong>多次性编程</strong>，同时支持局部擦写和全局擦写</p><h4 id="4-2-4-5-闪速型存储器-Flash-Memory）"><a href="#4-2-4-5-闪速型存储器-Flash-Memory）" class="headerlink" title="4.2.4.5 闪速型存储器 ( Flash Memory）"></a>4.2.4.5 闪速型存储器 ( Flash Memory）</h4><p>具备 RAM 的功能</p><p><em>主存可由RAM和ROM组成</em></p><h3 id="4-2-5-存储器与-CPU-的连接"><a href="#4-2-5-存储器与-CPU-的连接" class="headerlink" title="4.2.5 存储器与 CPU 的连接"></a>4.2.5 存储器与 CPU 的连接</h3><h4 id="4-2-5-1-存储容量的扩展"><a href="#4-2-5-1-存储容量的扩展" class="headerlink" title="4.2.5.1 存储容量的扩展"></a>4.2.5.1 存储容量的扩展</h4><p>存储容量的扩展 ， 通常有位扩展和字扩展</p><p><strong>位扩展</strong>是指<strong>增加存储字长</strong></p><p><strong>字扩展</strong>是指<strong>增加存储器字的数量</strong></p><p>位扩展：同一类连在一起的有对应的地址线、片选线、读写信号，分开连的有数据线。</p><p>字扩展：对应的数据线连在一起，将多出来的地址线作为片选信号。</p><p>字、位扩展：同时</p><h4 id="4-2-5-2-存储器与-CPU-的连接"><a href="#4-2-5-2-存储器与-CPU-的连接" class="headerlink" title="4.2.5.2 存储器与 CPU 的连接"></a>4.2.5.2 存储器与 CPU 的连接</h4><p>存储芯片与 CPU 芯片相连时需要注意地址线、数据线、读/写命令线、片选线的连接和合理选择存储芯片。</p><h5 id="（1）地址线的连接"><a href="#（1）地址线的连接" class="headerlink" title="（1）地址线的连接"></a>（1）地址线的连接</h5><ul><li>CPU的地址线数往往比一个存储芯片的地址线数要多。通常总是将CPU地址线的低位与存储芯片的地址线相连，CPU地址线的高位一般用于生成片选信号。 </li><li>如：8片1K×4位的芯片扩展成4K×8位的存储器，CPU地址线为12位，而存储芯片的地址线仅有10位。</li></ul><h5 id="（2）数据线的连接"><a href="#（2）数据线的连接" class="headerlink" title="（2）数据线的连接"></a>（2）数据线的连接</h5><ul><li>CPU的数据线数与存储芯片的数据线数也不一定相等。需要对存储芯片进行位扩展，使其与CPU的数据线数相等。</li><li>如：8片1K×4位的芯片扩展成4K×8位的存储器，CPU数据线为8位，而存储芯片的数据线仅有4位。</li></ul><h5 id="（3）片选线的连接"><a href="#（3）片选线的连接" class="headerlink" title="（3）片选线的连接"></a>（3）片选线的连接</h5><ul><li>片选线的连接是CPU与存储芯片正确工作的关键。哪一片存储芯片被选中主要取决于存储芯片的片选控制端𝐶𝑆能否接收到来自CPU的片选有效信号（低电平有效）。</li><li>片选有效信号与CPU访存控制信号𝑀𝑅𝐸𝑄 有关。只有当CPU要求访存时，才需要选择存储芯片。</li><li>片选有效信号还与地址有关。</li><li>在实际应用中，我们会使用访存控制信号𝑀𝑅𝐸𝑄 和高位地址共同产生片选有效信号。</li></ul><h5 id="（4）读-写命令线的连接"><a href="#（4）读-写命令线的连接" class="headerlink" title="（4）读/写命令线的连接"></a>（4）读/写命令线的连接</h5><ul><li>CPU的读/写命令线（ 𝑊𝐸 ）一般可以直接与存储芯片的读/写控制端相连，一般为高电平读，低电平写。</li></ul><h5 id="（5）合理选择存储芯片"><a href="#（5）合理选择存储芯片" class="headerlink" title="（5）合理选择存储芯片"></a>（5）合理选择存储芯片</h5><ul><li>合理选择存储芯片主要包括选择芯片类型（RAM或者ROM），以及芯片的数量。 </li><li>通常选用<strong>ROM存放系统程序</strong>、标准子程序和常数。 </li><li>选用<strong>RAM存放用户程序</strong>。</li></ul><h5 id="（6）其他：时序、负载等"><a href="#（6）其他：时序、负载等" class="headerlink" title="（6）其他：时序、负载等"></a>（6）其他：时序、负载等</h5><ul><li>CPU时序和存储器的时序要能够相互配合，才能够正确读出或写入数据。</li><li>负载考虑的是CPU最多可以带动多少片存储芯片。</li></ul><h3 id="4-2-6-存储器的校验"><a href="#4-2-6-存储器的校验" class="headerlink" title="4.2.6 存储器的校验"></a>4.2.6 存储器的校验</h3><h4 id="4-2-6-1-汉明码的组成"><a href="#4-2-6-1-汉明码的组成" class="headerlink" title="4.2.6.1 汉明码的组成"></a>4.2.6.1 汉明码的组成</h4><p><strong>编码最小距离</strong>是指在一种编码系统中 ， 任意两组合法代码之间的<strong>二进制位数</strong>的最少差异</p><p>编码最小距离 - 1 = 检错位数 + 纠错位数  且  检错位数 $\geq$ 纠错位数</p><p>$2^{检测位数}\geq 二进制代码位数 + 检测位数 + 1$</p><p>将 k 位检测位分别安插在 n + k 位代码编号的第$1,2,4,\dotsc,2^{k-1}$位上。</p><p>$g_i$ 小组独占第 $2^{i-1}$ 位</p><p>每两小组 $g_i$ 和 $g_j$ 共同占有第 $2^{i-1}+2^{j-1}$ 位</p><p>汉明码是一种具有<strong>一位</strong>纠错能力的编码</p><p>汉明码采用<strong>奇偶检验</strong>、<strong>分组校验</strong></p><p>汉明码的分组是一种<strong>非划分</strong>方式</p><h4 id="4-2-6-2-汉明码的纠错过程"><a href="#4-2-6-2-汉明码的纠错过程" class="headerlink" title="4.2.6.2 汉明码的纠错过程"></a>4.2.6.2 汉明码的纠错过程</h4><p>将传送后的海明码对应的每一小组进行异或，得到检测位 $P_i$。出错误位为 $P_nP_{n-1}\dotsc P_1$所构成的二进制值。</p><p>海明码常常被用在纠错一位的场合 </p><h3 id="4-2-7-提高访存速度的措施"><a href="#4-2-7-提高访存速度的措施" class="headerlink" title="4.2.7 提高访存速度的措施"></a>4.2.7 提高访存速度的措施</h3><p>提高访存速度的措施有：<strong>采用高速器件</strong>、<strong>采用层次结构</strong>(Cache-主存)、<strong>调整主存结构</strong></p><h4 id="4-2-7-1-单体多字系统"><a href="#4-2-7-1-单体多字系统" class="headerlink" title="4.2.7.1 单体多字系统"></a>4.2.7.1 单体多字系统</h4><p>在一个存取周期内 ， 从同一地址取岀连续的多条指令，在逐条将指令送往CPU执行。</p><p>单体多字系统优点：增加存储器带宽，提升单体存储器工作速度。</p><p>单体多字系统提升的前提：指令和数据在主存内必须是连续存放的</p><h4 id="4-2-7-2-多体并行系统"><a href="#4-2-7-2-多体并行系统" class="headerlink" title="4.2.7.2 多体并行系统"></a>4.2.7.2 多体并行系统</h4><p>多体并行系统就是采用多体模块组成的存储器。并行工作，同时访问N个模块、同时启动、同时读出</p><p>高位交叉：程序按体内地址存放 ， 一个体存满后 ， 再存入下一个体 。 显然 ， 高位地址可表示体号 。（各个体并行工作）</p><p>高位交叉编址的存储器能够提高访存速度的原因是<strong>各个体分别响应不同请求源的请求，实现多体并行</strong>。</p><p>高位交叉编址中，其地址的高位部分用于<strong>选择体号</strong>，低位部分用于<strong>选择存储体内的字</strong>。</p><p>低位交叉： 程序连续存放在相邻体中 ， 显然低位地址用来表示体号 ， 高位地址为体内地址 。（各个体轮流编址）</p><p>低位交叉的特点：<strong>在不改变存取周期的前提下，增加存储器带宽</strong>（<strong>带宽增加</strong>：CPU交叉访问各体，各体读/写过程重叠执行，一个存储周期，存储器实际向CPU提供了4个存储字)</p><p>流水线方式存取：设四体低位交叉存储器，存取周期为T，总线传输周期为t，为实现流水线方式存取，应满足 T ＝ 4*t。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617161256891.png" alt="image-20220617161256891"></p><h4 id="4-2-7-3-高性能存储芯片"><a href="#4-2-7-3-高性能存储芯片" class="headerlink" title="4.2.7.3 高性能存储芯片"></a>4.2.7.3 高性能存储芯片</h4><p><strong>同步 DRAM（SDRAM）</strong>： 在系统时钟的控制下进行读出和写入，CPU无需等待</p><p><strong>RDRAM</strong>：主要解决存储器带宽问题</p><p><strong>带Cache的DRAM（CDRAM）</strong>： 在 DRAM 的芯片内集成了一个由SRAM组成的 Cache，有利于猝发式读取，即CPU发出一个地址就可以连续访问一整个数据块（一般为32字节）。</p><h4 id="4-2-7-4-存储器控制部件（存控）"><a href="#4-2-7-4-存储器控制部件（存控）" class="headerlink" title="4.2.7.4 存储器控制部件（存控）"></a>4.2.7.4 存储器控制部件（存控）</h4><p><strong>主要功能</strong>：合理安排各个部件的访存顺序，并产生相应的读/写控制信号</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617161855101.png" alt="image-20220617161855101"></p><p><strong>排队器</strong>：同一时刻出现多个请求源访问同一存储体时，由排队器确定请求源访存的优先顺序</p><p><strong>存控标记触发器Cm</strong>：接收排队器输出的信号，一旦排队器响应某个请求源的请求， CM就会启动节拍发生器工作。 </p><p><strong>节拍发生器</strong>：产生固定节拍，使得控制线路能够按照一定的时序发出控制信号。 </p><p><strong>控制线路</strong>：接收排队器输出的信号和节拍器产生的节拍信号，向存储器输出各种控制信号，完成存储器读/写操作，并向请求源发出回答信号，表示已经响应了请求。</p><h2 id="4-3-高速缓冲存储器（Cache）"><a href="#4-3-高速缓冲存储器（Cache）" class="headerlink" title="4.3 高速缓冲存储器（Cache）"></a>4.3 高速缓冲存储器（Cache）</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><h4 id="4-3-1-1-为什么用-Cache"><a href="#4-3-1-1-为什么用-Cache" class="headerlink" title="4.3.1.1 为什么用 Cache"></a>4.3.1.1 为什么用 Cache</h4><p>缓存是设在<strong>CPU</strong>和<strong>主存</strong>之间的一种存储器，其速度与<strong>CPU速度</strong>匹配，其容量与<strong>缓存中数据的命中率</strong>有关。</p><p>CPU 和主存存在速度差异，为了<strong>避免 CPU 空等的现象</strong>，需要 Cache<img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617171904525.png" alt="image-20220617171904525"></p><h4 id="4-3-1-2-Cache-的工作原理"><a href="#4-3-1-2-Cache-的工作原理" class="headerlink" title="4.3.1.2 Cache 的工作原理"></a>4.3.1.2 Cache 的工作原理</h4><h5 id="（1）主存和缓存的编址"><a href="#（1）主存和缓存的编址" class="headerlink" title="（1）主存和缓存的编址"></a>（1）主存和缓存的编址</h5><p>主存与缓存按块存储，块的大小相同，块内地址相同。</p><p>主存块的数量远大于Cache块的数量</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617173950282.png" alt="image-20220617173950282"></p><h5 id="（2）命中与未命中"><a href="#（2）命中与未命中" class="headerlink" title="（2）命中与未命中"></a>（2）命中与未命中</h5><p>命中：要访问的主存块已经调入缓存，主存块与缓存块建立了对应关系。</p><p>用标记记录与某缓存块建立了对应关系的主存块号</p><p>Cache 的命中率：CPU欲访问的信息在 Cache 中的比率</p><h5 id="（3）Cache的命中率"><a href="#（3）Cache的命中率" class="headerlink" title="（3）Cache的命中率"></a>（3）Cache的命中率</h5><p>CPU欲访问的信息在Cache中的比率，命中率与 Cache 的<strong>容量</strong>与<strong>块长</strong>有关，一般每块可取 4~8 个字。</p><p>块长：一个存储周期内从主存获取的信息长度</p><h5 id="（4）Cache-主存系统的效率"><a href="#（4）Cache-主存系统的效率" class="headerlink" title="（4）Cache-主存系统的效率"></a>（4）Cache-主存系统的效率</h5><p>效率e与命中率有关</p><p>Cache-主存系统的效率 $e = \cfrac{访问 Cache 的时间}{平均访问时间} \times 100%$</p><p>设Cache命中率为h，访问 Cache 的时间为tc，访问主存的时间为tm，则 $e = \cfrac{t_c}{h×t_c+(1-h)×t_m} \times 100%$</p><p>假设访问Cache和访问主存是同时进行的</p><h4 id="4-3-1-3-Cache-的基本结构"><a href="#4-3-1-3-Cache-的基本结构" class="headerlink" title="4.3.1.3 Cache 的基本结构"></a>4.3.1.3 Cache 的基本结构</h4><p>Cache 由 Cache 存储体 、 地址映射变换机构 、 Cache 替换机构几大模块组成<img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617192255485.png" alt="image-20220617192255485"></p><p>将主存地址映射到缓存中定位称为地址映射 </p><p>将主存地址变换成缓存地址称为地址变换</p><p>当新的主存块需要调入缓存中，而它的可用位置又被占用时，需根据替换算法解决调入问题</p><p>Cache的读操作：</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/360MoveData/Users/MARVEL/Desktop/计组复习/note_thj_202206/计算机组成原理Note.assets/image-20200330231535717.png" alt="image-20200330231535717"></p><p>Cache 写操作中保持与主存一致的方法有：写直达法、写回法</p><p><strong>写直达法</strong>：写操作时既写入Cache又写入主存，写操作时间就是<strong>访问主存</strong>的时间</p><p>读操作时不涉及对主存的写操作，更新策略比较容易实现</p><p><em>写直达法能随时保证主存和cache的数据始终一致，但增加了访存次数</em>。</p><p><strong>写回法</strong>：写操作时只写入Cache而不写入主存，当Cache数据被替换出去时才写回主存，写操作时间就是<strong>访问 Cache的时间</strong></p><p>读操作Cache失效发生数据替换时，被替换的块需写回主存，增加了Cache的复杂性</p><h4 id="4-3-1-4-Cache-的改进"><a href="#4-3-1-4-Cache-的改进" class="headerlink" title="4.3.1.4 Cache 的改进"></a>4.3.1.4 Cache 的改进</h4><p>改进方法：增加Cache的级数、将统一的 Cache 变成分开的<br>Cache</p><p>两级缓存包括片内Cache和片外Cache</p><p>分开缓存分别为指令Cache和数据Cache</p><h3 id="4-3-2-Cache—主存地址映射"><a href="#4-3-2-Cache—主存地址映射" class="headerlink" title="4.3.2 Cache—主存地址映射"></a>4.3.2 Cache—主存地址映射</h3><h4 id="4-3-2-1-直接映射"><a href="#4-3-2-1-直接映射" class="headerlink" title="4.3.2.1 直接映射"></a>4.3.2.1 直接映射</h4><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617193843541.png" alt="image-20220617193843541"></p><p>每个主存块只与一个缓存块相对应</p><p>判断一段主存地址是否命中的过程：先根据中间c位字段找到Cache字块，再判断标记是否等于高 t 位，最后判断有效位是否等于 1。</p><p>优点：实现/使用简单、<em>速度快</em></p><p>缺点：不够灵活、不能充分利用缓存的存储空间、命中率低</p><h4 id="4-3-2-2-全相联映射"><a href="#4-3-2-2-全相联映射" class="headerlink" title="4.3.2.2 全相联映射"></a>4.3.2.2 全相联映射</h4><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617194126049.png" alt="image-20220617194126049"></p><p>主存中每一字块映射到 Cache 中的任何一块位置上</p><p>主存地址高 m 为被分成两部分：低 b位指 Cache 的字块内地址，高 m位指主存字块标记。</p><p>优点：<strong>灵活性强</strong>、命中率高</p><p>缺点：电路复杂、<strong>成本较高</strong>、速度慢、比较次数多</p><p>比较通常采用“按内容寻址”的相联存储器来实现。</p><h4 id="4-3-2-2-组相联映射"><a href="#4-3-2-2-组相联映射" class="headerlink" title="4.3.2.2 组相联映射"></a>4.3.2.2 组相联映射</h4><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617194526372.png" alt="image-20220617194526372"></p><p>组相联映射是直接映射和全相联映射的结合</p><p>将 Cache 分组，主存的某一字块可以按模映射到 Cache 某组的任一字块中</p><h3 id="4-3-3-缓存替换算法"><a href="#4-3-3-缓存替换算法" class="headerlink" title="4.3.3 缓存替换算法"></a>4.3.3 缓存替换算法</h3><p>当新的主存块需要调入 Cache 并且它的可用空间位置又被占满时 ， 就产生了一个替换算法 （ 策略 ） 问题 。</p><p>常用的两种算法：先进先出算法、近期最少使用算法等。</p><h4 id="4-3-3-1-先进先出-FIFO-算法"><a href="#4-3-3-1-先进先出-FIFO-算法" class="headerlink" title="4.3.3.1 先进先出(FIFO)算法"></a>4.3.3.1 先进先出(FIFO)算法</h4><p>当Cache占满时，它总是选择最早调入Cache的字块进行替换。</p><p>优点：先进先出法容易实现、开销小，不需要记录Cache中各字块的使用情况。</p><p>缺点：没有基于访存的局部性原理，不能提高Cache的命中率。</p><h4 id="4-3-3-2-近期最少使用-LRU-算法"><a href="#4-3-3-2-近期最少使用-LRU-算法" class="headerlink" title="4.3.3.2 近期最少使用(LRU)算法"></a>4.3.3.2 近期最少使用(LRU)算法</h4><p>当Cache占满时，选择近期用得最少的字块进行替换。</p><p>近期最少使用法需要随时记录Cache中各个缓存块的使用情况（记录从上一次使用到此刻的时间），并将间隔时间最长的缓存块替换掉，实现较为复杂。</p><p>近期最少使用法（LRU）的平均命中率比先进先出法（FIFO）要高，用到程序局部性原理。</p><h4 id="4-3-3-3-最不经常使用-LFU-算法"><a href="#4-3-3-3-最不经常使用-LFU-算法" class="headerlink" title="4.3.3.3 最不经常使用(LFU)算法"></a>4.3.3.3 最不经常使用(LFU)算法</h4><p>最不经常使用法的思路与近期最少使用法类似，当Cache占满时，选择最不经常使用的字块进行替换。</p><p>最不经常使用法也需要随时记录Cache中各个缓存块的使用情况（记录一定时间内每个缓存块被访问的次数），并将访问次数最少的缓存块替换掉，<strong>实现也较为复杂</strong>。</p><p>最不经常使用法的平均命中率比先进先出法要高。</p><h4 id="4-3-3-4-随机替换法"><a href="#4-3-3-4-随机替换法" class="headerlink" title="4.3.3.4 随机替换法"></a>4.3.3.4 随机替换法</h4><p>当Cache占满时，随机选择一个缓存块替换。</p><p>实现简单，但是也没有考虑程序访问的局部性原理，无法提高Cache的命中率。</p><h2 id="4-4-虚拟存储器"><a href="#4-4-虚拟存储器" class="headerlink" title="4.4 虚拟存储器"></a>4.4 虚拟存储器</h2><h3 id="4-4-1-虚拟存储器思想的提出"><a href="#4-4-1-虚拟存储器思想的提出" class="headerlink" title="4.4.1 虚拟存储器思想的提出"></a>4.4.1 虚拟存储器思想的提出</h3><p>虚拟存储器处于“主存-辅存”存储层次，通过在主存和辅存之间增加部分软件（操作系统）和必须的硬件（地址映射与转换机构、缺页中断结构等），使辅存和主存构成一个有机整体。</p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617201259558.png" alt="image-20220617201259558" style="zoom:80%;"><h4 id="4-4-1-1-提出背景"><a href="#4-4-1-1-提出背景" class="headerlink" title="4.4.1.1 提出背景"></a>4.4.1.1 提出背景</h4><ul><li><strong>主存容量限制</strong>带来的诸多不便<ul><li>用户编写程序必须考虑主存容量的限制</li><li>多道程序设计的道数受到限制</li></ul></li><li><strong>用户编程行为分析</strong><ul><li>全面考虑各种情况，执行时有互斥性</li><li>顺序性和循环性等空间局部性行为<ul><li>空间局部性：一旦程序访问了某个存储单元，其附近的存储单元也将在不久之后被访问</li></ul></li><li>某一阶段执行的时间局部性行为<ul><li>时间局部性：某条指令一旦执行，不久的将来可能被再次执行</li></ul></li></ul></li><li><strong>因此可以考虑只将进程涉及的部分内容调入内存</strong></li></ul><h4 id="4-4-1-2-基本思想"><a href="#4-4-1-2-基本思想" class="headerlink" title="4.4.1.2 基本思想"></a>4.4.1.2 基本思想</h4><ul><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为<strong>随用随调入</strong></li><li>如果主存中没有足够的空间，存储管理需要根据执行行为把主存中暂时不用的信息调出到辅存上去</li><li>虚拟存储采用与Cache类似原理，提高速度，降低成本</li><li>利用<strong>程序局部性</strong>，使存储系统的性能接近于高速存储器；价格接近于低速存储器，并扩充主存容量</li></ul><h3 id="4-4-2-虚拟存储器的实现"><a href="#4-4-2-虚拟存储器的实现" class="headerlink" title="4.4.2 虚拟存储器的实现"></a>4.4.2 虚拟存储器的实现</h3><ul><li>需要建立与自动管理两个地址空间<ul><li>辅存对应的虚拟地址空间，容纳进程装入</li><li>主存对应的实际地址空间，承载进程执行</li></ul></li><li>例子：32位的计算机，内存大小为1GB。对于程序员来说，可用地址空间为4GB，大于实际主存大小。实际上就采用了虚拟存储器技术：<ul><li>4GB实际上使用的是辅存（磁盘）中的空间，仅使用1GB的内存就可实现4GB的地址空间</li><li>进程在执行时首先都被装入辅存中，只将一部分代码和数据装入到1GB的内存中。后续根据进程的执行行为再陆续将需要执行的代码和数据调入到1GB的内存中。当内存被装满时，需要将不再使用的数据调出到辅存，为需要的数据腾出空间。</li></ul></li><li>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计。<em>（透明：用户（包括程序员）不需要了解辅存与主存之间的数据调入和换出是如何实现。从用户角度来看，使用的就是1台内存地址空间大小为4GB的计算机。）</em></li></ul><h4 id="4-4-2-1-虚地址计算机系统"><a href="#4-4-2-1-虚地址计算机系统" class="headerlink" title="4.4.2.1 虚地址计算机系统"></a>4.4.2.1 虚地址计算机系统</h4><p><strong>实地址计算机系统</strong>：CPU给出的地址直接访问<strong>物理内存</strong>（大多数Cray计算机、早期PC、大多数嵌入式系统）</p><p><strong>虚地址计算机系统</strong>：CPU给出的地址需要<strong>虚实变换</strong>，即通过<strong>地址映射与转换机构</strong>以及操作系统维护的<strong>页表</strong>将虚拟地址转换为物理地址（工作站、服务器、现代PC）</p><p>页：虚拟存储器中的存储单元，默认大小为4KB，因此需要12位页内偏移地址。对于4GB的虚拟存储器，页表项有4GB/4KB=$2^{20}$项。<img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617203304744.png" alt="image-20220617203304744" style="zoom:80%;"> </p><p>页式虚拟存储器：以页（page）为逻辑结构划分信息传送单位的虚拟存储器</p><h4 id="4-4-2-2-页表结构"><a href="#4-4-2-2-页表结构" class="headerlink" title="4.4.2.2 页表结构"></a>4.4.2.2 页表结构</h4><p>Page Table(页表，查找表)：一张保存虚拟页号和物理页号对应关系的查找表。常驻内存</p><p>虚拟地址—&gt;物理地址（页命中/未命中(缺页)）</p><p><strong>VA</strong>（Virtual Address）  <strong>PA</strong>（Physical Address）</p><p><strong>MMU</strong>（Memory Management Unit）</p><p><strong>PTE</strong> (Page Table Entry)：页表项</p><p><strong>VPN</strong>(Virtual Page Number)：虚拟页号</p><p><strong>PPN</strong>(Physical Page Number)：物理页号</p><p>虚拟地址：虚拟页号+页内偏移</p><p>实地址：实页号+页内偏移</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617204415264.png" alt="image-20220617204415264"></p><h4 id="4-4-2-3-页式虚拟存储器的访问流程"><a href="#4-4-2-3-页式虚拟存储器的访问流程" class="headerlink" title="4.4.2.3 页式虚拟存储器的访问流程"></a>4.4.2.3 页式虚拟存储器的访问流程</h4><h5 id="（1）页面命中"><a href="#（1）页面命中" class="headerlink" title="（1）页面命中"></a>（1）页面命中</h5><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617204618106.png" alt="image-20220617204618106"></p><h5 id="（2）页面缺失"><a href="#（2）页面缺失" class="headerlink" title="（2）页面缺失"></a>（2）页面缺失</h5><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617205009996.png" alt="image-20220617205009996"></p><h4 id="4-4-2-4-使用快表（TLB）提高页式管理速度"><a href="#4-4-2-4-使用快表（TLB）提高页式管理速度" class="headerlink" title="4.4.2.4 使用快表（TLB）提高页式管理速度"></a>4.4.2.4 使用快表（TLB）提高页式管理速度</h4><p>页表存放在主存，虚存空间即使命中也须先查页表，再访问主存，两次访存才能取出数据，速度慢。为提高页表查找速度，采用Cache的方法，引入一个体积小的快表，存放页表中经常被访问的表项。</p><p><strong>TLB</strong>(Translation Lookaside Buffer)：快表，页表缓冲</p><p>CPU寻址时，使用虚拟地址，优先在TLB中寻址，TLB负责将虚拟内存地址翻译成实际的物理内存地址，从而可以<strong>加速主存和辅存间访问速度</strong></p><h5 id="4-4-2-4-1-TLB虚实地址转换"><a href="#4-4-2-4-1-TLB虚实地址转换" class="headerlink" title="4.4.2.4.1 TLB虚实地址转换"></a>4.4.2.4.1 TLB虚实地址转换</h5><ul><li>采用TLB后，对虚拟地址进行二次划分，主要是把VPN划分为TLB Tag和TLB index，页内偏移地址不变。 </li><li>当CPU传送一个新的虚拟地址后，从虚拟地址中划分出TLB Tag和TLB index，使用TLB index找到快表中对应的页表项，比较当前虚拟地址的TLB Tag和页表项中存储的TLB Tag是否相同。<strong>如果相同且有效位为1，则快表命中，直接基于页表项中存储的物理页号生成物理地址；否则，快表未命中，需要访问主存中的页表</strong>。 </li><li>TLB中存放的是页表的子集，取决于TLB Index的位数。因此，不同的虚拟页可能会有相同的TLB Index，需要通过TLB Tag来区分。这类似于Cache的直接相连映射。</li><li><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617210458253.png" alt="image-20220617210458253" style="zoom:80%;"></li></ul><h5 id="4-4-2-4-2-带有快表的虚存访问流程"><a href="#4-4-2-4-2-带有快表的虚存访问流程" class="headerlink" title="4.4.2.4.2 带有快表的虚存访问流程"></a>4.4.2.4.2 带有快表的虚存访问流程</h5><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617210639150.png" alt="image-20220617210639150"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617210653214.png" alt="image-20220617210653214"></p><h3 id="4-4-3-虚拟存储器与Cache的异同"><a href="#4-4-3-虚拟存储器与Cache的异同" class="headerlink" title="4.4.3 虚拟存储器与Cache的异同"></a>4.4.3 虚拟存储器与Cache的异同</h3><h4 id="4-4-3-1-虚拟存储器与Cache的相似之处"><a href="#4-4-3-1-虚拟存储器与Cache的相似之处" class="headerlink" title="4.4.3.1 虚拟存储器与Cache的相似之处"></a>4.4.3.1 虚拟存储器与Cache的相似之处</h4><ul><li><p>将程序中常用的部分驻留在高速存储器</p><ul><li>程序载入按需载入（不是全部载入）</li><li>高速存储器分块或者分页（粒度问题）</li><li>主存空间满，将不常用程序或数据<strong>淘汰</strong>或<strong>交换</strong>到辅存中</li></ul></li><li><p>数据的换入换出由硬件或操作系统完成，对用户透明</p></li><li><p>利用程序局部性，使存储系统的性能接近于高速存储器；</p><p>价格接近于低速存储器，并扩充主存容量</p></li></ul><h4 id="4-4-3-2-虚拟存储器与Cache的差异"><a href="#4-4-3-2-虚拟存储器与Cache的差异" class="headerlink" title="4.4.3.2 虚拟存储器与Cache的差异"></a>4.4.3.2 虚拟存储器与Cache的差异</h4><ul><li>虚存用于扩大主存容量，Cache用于加速主存性能</li><li>虚存中未命中性能损失远大于Cache系统<ul><li>全相联提升命中率</li><li>更大的交换单位页</li><li>近似LRU算法 (CLOCK算法) </li></ul></li><li>虚存由<strong>硬件</strong>和<strong>操作系统</strong>OS联合管理，Cache由硬件管理<ul><li>进程及进程上下文切换、存储器分配</li><li>虚拟地址空间管理、缺页处理</li><li>存储器保护</li></ul></li></ul><h2 id="4-5-辅助存储器"><a href="#4-5-辅助存储器" class="headerlink" title="4.5 辅助存储器"></a>4.5 辅助存储器</h2><h3 id="4-5-1-主要类型"><a href="#4-5-1-主要类型" class="headerlink" title="4.5.1 主要类型"></a>4.5.1 主要类型</h3><p>硬盘，U盘，软盘，光盘，磁带等</p><p>特点：不直接与 CPU 交换信息</p><p>磁表面存储器的主要技术指标：记录密度、存储容量、平均寻址时间、数据传输率、误码率</p><p>寻址时间分为两个部分：找道时间和等待时间</p><h4 id="4-5-1-1-磁记录原理"><a href="#4-5-1-1-磁记录原理" class="headerlink" title="4.5.1.1 磁记录原理"></a>4.5.1.1 磁记录原理</h4><p>磁表面存储器通过磁头和记录介质的相对运动完成读写操作 </p><p>根据写入驱动电流的不同方向 ，使磁层表面被磁化的极性方向不同 ， 以区别记录 “ 0 ” 或 “ 1 ” </p><h4 id="4-5-1-2-硬磁盘存储器"><a href="#4-5-1-2-硬磁盘存储器" class="headerlink" title="4.5.1.2 硬磁盘存储器"></a>4.5.1.2 硬磁盘存储器</h4><p>按磁头分类：固定磁头和移动磁头</p><p>按盘片分类：可换盘和固定盘</p><p>硬磁盘存储器是由磁盘驱动器 、 磁盘控制器和盘片组成</p><p>磁盘驱动器的主要包括主轴 、定位驱动及数据控制等</p><p>磁盘控制器是主机与磁盘驱动器之间的接口</p><p>盘片是存储信息的载体</p><h4 id="4-5-1-3-软磁盘存储器"><a href="#4-5-1-3-软磁盘存储器" class="headerlink" title="4.5.1.3 软磁盘存储器"></a>4.5.1.3 软磁盘存储器</h4><p>软磁盘存储器的盘片是用类似塑料薄膜唱片的柔性材料制成的</p><p>软盘转速低 ， 存取速度慢</p><p>软盘都是活动头 ， 可换盘片结构</p><p>软盘磁头直接接触盘片进行读写</p><p>软盘价格便宜 ， 盘片保存方便 、使用灵活 、 具有互换性</p><p>软盘对环境的要求不苛刻</p><h4 id="4-5-1-4-光盘存储器"><a href="#4-5-1-4-光盘存储器" class="headerlink" title="4.5.1.4 光盘存储器"></a>4.5.1.4 光盘存储器</h4><p>第一代光存储技术采用非磁性介质，不可擦写</p><p>第一代光存储技术采用磁性介质，可擦写</p><h3 id="4-5-2-磁盘冗余阵列技术RAID"><a href="#4-5-2-磁盘冗余阵列技术RAID" class="headerlink" title="4.5.2 磁盘冗余阵列技术RAID"></a>4.5.2 磁盘冗余阵列技术RAID</h3><ul><li><p>把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成的一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。</p></li><li><p>产生原因：磁盘访问速度过慢，可靠性：磁盘故障导致数据丢失，多磁盘管理不方便</p></li><li><p>将<strong>数据条带化</strong>后存放在不同磁盘上，通过多磁盘的<strong>并行</strong>操作提高磁盘系统的读写速率</p></li><li><p>使用基于<strong>异或</strong>运算为基础的校验技术<strong>恢复损坏的数据</strong></p></li></ul><p>常见的几种RAID技术：</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221148896.png" alt="image-20220617221148896"></p><p> <img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221158282.png" alt="image-20220617221158282"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Users\MARVEL\AppData\Roaming\Typora\typora-user-images\image-20220617221243080.png" alt="image-20220617221243080"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221256766.png" alt="image-20220617221256766"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221305435.png" alt="image-20220617221305435"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221316704.png" alt="image-20220617221316704"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221329742.png" alt="image-20220617221329742"></p><p>软件RAID:依赖于主机CPU完成，没有第三方的控制处理器和I/O芯片</p><p>硬件RAID:专用RAID控制处理器和I/O芯片处理RAID任务，不占CPU</p><p>RAID小结：</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220617221411619.png" alt="image-20220617221411619"></p><h1 id="5-输入输出系统"><a href="#5-输入输出系统" class="headerlink" title="5 输入输出系统"></a>5 输入输出系统</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><h3 id="5-1-1-输入输出设备与特性"><a href="#5-1-1-输入输出设备与特性" class="headerlink" title="5.1.1 输入输出设备与特性"></a>5.1.1 输入输出设备与特性</h3><p><strong>输入输出设备</strong>是计算机与人或者机器系统进行数据交互的装置，用于实现计算机内部二进制信息与外部不同形式信息的转换，简称<strong>外部设备</strong>或<strong>外设</strong></p><ul><li><strong>输入设备：</strong>负责将数据、文字、图像、声音、电信号等转换成计算机可以识别的二进制信息，如键盘、鼠标、扫描仪、摄像头等</li><li><strong>输出设备：</strong>负责将计算机处理结果转换成数字、文字、图形、图像、声音或电信号，如显示器、打印机等</li><li><strong>输入输出设备</strong>：既能输入也能输出，如磁盘、网卡等</li></ul><p>输入输出设备特性：异步性、实时性、独立性</p><p><strong>输入/输出系统的组成与功能</strong>：</p><ul><li><strong>输入输出系统：</strong>外部设备、接口部件、总线以及相应的管理软件的统称，简称I/O系统<ul><li>完成计算机内部二进制信息与外部多种信息形式间的交流</li><li>保证CPU能够正确选择I/O设备并实现对其控制，与数据传输</li><li>利用数据缓冲、合适的数据传送方式，实现主机外设间速度匹配</li></ul></li></ul><h3 id="5-1-2-输入输出系统的发展概况"><a href="#5-1-2-输入输出系统的发展概况" class="headerlink" title="5.1.2 输入输出系统的发展概况"></a>5.1.2 输入输出系统的发展概况</h3><h4 id="5-1-1-1-早期阶段"><a href="#5-1-1-1-早期阶段" class="headerlink" title="5.1.1.1 早期阶段"></a>5.1.1.1 早期阶段</h4><ul><li><p><strong>分散连接</strong>：每个 I/O 设备都必须配有一套独立的逻辑电路与 CPU 相连，以完成I/O设备与主存的信息交换。</p></li><li><p><strong>CPU和I/O设备串行工作</strong>：输入输出过程穿插在程序执行过程之中进行，当I/O设备与主机交换信息时，CPU必须等待。</p></li><li><p><strong>采用程序查询方式与主存交换信息</strong></p></li></ul><h4 id="5-1-1-2-接口模块和-DMA-阶段"><a href="#5-1-1-2-接口模块和-DMA-阶段" class="headerlink" title="5.1.1.2 接口模块和 DMA 阶段"></a>5.1.1.2 接口模块和 DMA 阶段</h4><ul><li> <strong>总线连接</strong>：计算机系统采用总线结构，I/O设备通过接口模块与主机连接。</li><li> <strong>I/O设备和CPU按照并行方式工作</strong>：接口模块中包含有数据通路和控制通路，通过接口可以使得I/O设备和CPU按照并行方式工作，还可以使得多台I/O设备分时占用总线，使得I/O设备之间也可实现并行工作。</li><li> <strong>主要采用程序中断方式和DMA方式完成I/O设备与主机间的信息交换</strong></li></ul><h4 id="5-1-1-3-具有通道结构的阶段"><a href="#5-1-1-3-具有通道结构的阶段" class="headerlink" title="5.1.1.3 具有通道结构的阶段"></a>5.1.1.3 具有通道结构的阶段</h4><p>对于大型计算机，I/O设备数量非常多，数据传输频繁，采用DMA方式进行信息交换会出现成本高、控制复杂的问题。</p><ul><li>大型计算机往往采用I/O通道的方式进行数据交换。</li><li><strong>I/O通道</strong>可以视为一个具有特殊功能的处理器，主要负责管理I/O设备以及实现主存与I/O设备之间的信息交换。</li><li>依赖I/O通道管理设备，不占用CPU的资源，提高CPU的效率。 </li></ul><h4 id="5-1-1-4-具有I-O处理机的阶段"><a href="#5-1-1-4-具有I-O处理机的阶段" class="headerlink" title="5.1.1.4 具有I/O处理机的阶段"></a>5.1.1.4 具有I/O处理机的阶段</h4><p>I/O处理机又称为外围处理机，独立于主机（CPU）工作。 </p><p>I/O处理机除了完成I/O通道需要完成的输入输出设备的I/O控制以外，还可以独立完成数据格式转换、数据检错纠错等任务。</p><p>具有I/O处理机的输入输出系统对主机来说具有更大的独立性，与CPU工作的并行性更高。</p><h3 id="5-1-3-输入输出系统的组成"><a href="#5-1-3-输入输出系统的组成" class="headerlink" title="5.1.3 输入输出系统的组成"></a>5.1.3 输入输出系统的组成</h3><p>输入输出系统应该由 I/O 软件和 I/O 硬件两部分组成 </p><h4 id="5-1-2-1-I-O-软件"><a href="#5-1-2-1-I-O-软件" class="headerlink" title="5.1.2.1 I/O 软件"></a>5.1.2.1 I/O 软件</h4><p>（1）I/O 指令</p><p>I/O 指令是机器指令的一部分（操作码+命令码+设备码）</p><p><em>设备码给出的是I/O设备的编码/地址，或者是I/O设备当中某一个寄存器的地址。这些寄存器我们把它叫做I/O端口</em></p><p>I/O 指令的命令码一般可以表述的情况有：将数据从I/O设备输入主机、将数据从主机输出至I/O设备、状态测试、形成某些操作命令</p><p>（2）通道指令</p><p>通道指令是对具有通道的 I/O 系统专门设置的指令</p><p>通道程序是由通道控制字组成</p><p>通道指令指出数组的首地址、传送字数、操作命令</p><h4 id="5-1-2-2-I-O-硬件"><a href="#5-1-2-2-I-O-硬件" class="headerlink" title="5.1.2.2 I/O 硬件"></a>5.1.2.2 I/O 硬件</h4><p>一般包括接口模块及I/O设备两大部分</p><p>一个通道可以和一个以上的设备控制器相连 ， 一个设备控制器又可以控制若干台同一类型的设备。</p><h3 id="5-1-4-I-O-设备与主机的联系方式"><a href="#5-1-4-I-O-设备与主机的联系方式" class="headerlink" title="5.1.4 I/O 设备与主机的联系方式"></a>5.1.4 I/O 设备与主机的联系方式</h3><h4 id="5-1-3-1-I-O-设备编址方式"><a href="#5-1-3-1-I-O-设备编址方式" class="headerlink" title="5.1.3.1 I/O 设备编址方式"></a>5.1.3.1 I/O 设备编址方式</h4><p>对 I/O 地址码的编址可采用两种方式 ： 统一编址或独立编址（不统一编址）</p><p>统一编址就是将 I/O 地址看作是存储器地址的一部分</p><ul><li>内存映射编址（Memory-mapped），占用主存</li><li>外设地址与内存地址统一编址，同一个地址空间</li><li>不需要设置专用的I/O指令</li><li>采用访存指令（取数、存数指令）访问外设，具体访问什么设备取决于地址</li></ul><p>独立编址有专门的 I/O 指令</p><ul><li>端口映射编址（Port-mapped），不占用主存</li><li>I/O地址空间与主存地址空间相互独立</li><li>I/O地址又称为I/O端口</li><li>不同设备中的不同寄存器和存储器都有唯一的端口地址</li><li>使用I/O指令访问外设</li></ul><h4 id="5-1-3-2-设备寻址"><a href="#5-1-3-2-设备寻址" class="headerlink" title="5.1.3.2 设备寻址"></a>5.1.3.2 设备寻址</h4><p>每台I/O设备都有唯一设备号，用设备选择电路识别“I/O指令的设备码字段”是否被选中</p><h4 id="5-1-3-3-传送方式"><a href="#5-1-3-3-传送方式" class="headerlink" title="5.1.3.3 传送方式"></a>5.1.3.3 传送方式</h4><p>数据的传送方式包括串行和并行。</p><h4 id="5-1-3-4-联络方式"><a href="#5-1-3-4-联络方式" class="headerlink" title="5.1.3.4 联络方式"></a>5.1.3.4 联络方式</h4><p>按 I/O 设备工作速度的不同 ， 可分为三种联络方式：立即响应方式、 异步工作采用应答信号联络、 同步工作釆用同步时标联络</p><p>（1）<strong>立即响应方式</strong>：I/O设备与CPU发生联系时，通常已经处于某种等待状态。只要CPU的I/O指令一到，这些设备就可立即响应，不需要特殊的联络信号。 适用于工作速度十分缓慢的I/O设备，例如：指示灯的亮与灭。 </p><p>（2）<strong>同步工作采用同步时标联络</strong>：需要在I/O设备和CPU之间配备专有电路，用以产生同步时标来控制同步工作。例如：以I/O设备输入数据为例。假设I/O设备以2400bps的速率将数据传输到I/O接口，则CPU也必须以(1/2400)s的速率接收每一位数据。适用于I/O设备与CPU的工作速度完全同步的情况。</p><p>（3）<strong>异步工作采用应答信号</strong>：在交换信息前，I/O设备和CPU各自执行自己的任务，一旦出现联络信号，彼此才交换信息。适用于I/O设备与主机工作速度不匹配情形。</p><h4 id="5-1-3-5-I-O-与主机的连接方式"><a href="#5-1-3-5-I-O-与主机的连接方式" class="headerlink" title="5.1.3.5 I/O 与主机的连接方式"></a>5.1.3.5 I/O 与主机的连接方式</h4><p>I/O 设备与主机的连接方式通常有两种 ： 辐射式和总线式</p><p>辐射式连接：每台设备都配有一套控制线路和一组信号线，不便于增删设备。</p><p>总线连接：通过一组总线（包括地址线、数据线和控制线）将所有的I/O设备与主机相连，便于增删设备。</p><h3 id="5-1-5-I-O-与主机信息传送的控制方式"><a href="#5-1-5-I-O-与主机信息传送的控制方式" class="headerlink" title="5.1.5 I/O 与主机信息传送的控制方式"></a>5.1.5 I/O 与主机信息传送的控制方式</h3><h4 id="5-1-4-1-程序查询方式"><a href="#5-1-4-1-程序查询方式" class="headerlink" title="5.1.4.1 程序查询方式"></a>5.1.4.1 程序查询方式</h4><p>程序查询方式是CPU通过程序不断查询 I/O 设备是否准备就绪，根据查询结果来决定I/O设备是否与主机交换信息的工作方式。</p><p>需要I/O接口设置一个能反映I/O设备是否准备就绪的状态标记，供CPU查询。</p><p>主机和设备传送数据时，采用程序查询方式，CPU 和 I/O <strong>串行</strong>工作。</p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618172840188.png" alt="image-20220618172840188" style="zoom: 80%;"><h4 id="5-1-4-2-程序中断方式"><a href="#5-1-4-2-程序中断方式" class="headerlink" title="5.1.4.2 程序中断方式"></a>5.1.4.2 程序中断方式</h4><p>I/O 工作分为两个阶段：自身准备（CPU不查询）、与主机交换信息（CPU暂停现行程序）</p><p>CPU 和 I/O 部分的<strong>并行</strong>工作，没有踏步等待现象</p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618173058360.png" alt="image-20220618173058360" style="zoom:80%;"><p>中断向量地址是中断服务程序入口地址的地址</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618173143721.png" alt="image-20220618173143721"></p><h4 id="5-1-4-3-DMA-方式"><a href="#5-1-4-3-DMA-方式" class="headerlink" title="5.1.4.3 DMA 方式"></a>5.1.4.3 DMA 方式</h4><p>在 DMA 方式中，主存与 I/O 设备之间有一条数据通路，主存与 I/O 设备交换信息时，无需处理中断服务程序。 </p><p>若出现 DMA 和 CPU 同时访问主存, CPU总是将总线占有权让给 DMA, 通常把 DMA 的这种占有叫做 “ 周期窃取”（或周期挪用）， 窃取的时间一般为一个存取周期 ， 故又把 DMA 占用的存取周期叫做 “ 窃取周期 ” 或 “ 挪用周期 ” 。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618174404042.png" alt="image-20220618174404042"></p><h2 id="5-2-外部设备"><a href="#5-2-外部设备" class="headerlink" title="5.2 外部设备"></a>5.2 外部设备</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>外部设备大致分三类：人机交互设备、计算机信息存储设备、机—机通信设备</p><h3 id="5-2-2-输入设备"><a href="#5-2-2-输入设备" class="headerlink" title="5.2.2 输入设备"></a>5.2.2 输入设备</h3><h4 id="5-2-2-1-键盘"><a href="#5-2-2-1-键盘" class="headerlink" title="5.2.2.1 键盘"></a>5.2.2.1 键盘</h4><p>键盘输入信息的三个步骤：按键、判断哪个键按下、将此键翻译成 ASCII 码</p><h4 id="5-2-2-2-鼠标器"><a href="#5-2-2-2-鼠标器" class="headerlink" title="5.2.2.2 鼠标器"></a>5.2.2.2 鼠标器</h4><p>鼠标器的两种形式：机械式、光电式</p><h4 id="5-2-2-3-触摸屏"><a href="#5-2-2-3-触摸屏" class="headerlink" title="5.2.2.3 触摸屏"></a>5.2.2.3 触摸屏</h4><h3 id="5-2-3-输出设备"><a href="#5-2-3-输出设备" class="headerlink" title="5.2.3 输出设备"></a>5.2.3 输出设备</h3><h4 id="5-2-3-1-显示设备"><a href="#5-2-3-1-显示设备" class="headerlink" title="5.2.3.1 显示设备"></a>5.2.3.1 显示设备</h4><p>显示设备按显示内容分有字符显示器、图形显示器和图像显示器</p><p>图形显示所显示的图形又称主观图像</p><p>图像显示多显示的图像又称客观图像</p><h4 id="5-2-3-2-打印机"><a href="#5-2-3-2-打印机" class="headerlink" title="5.2.3.2 打印机"></a>5.2.3.2 打印机</h4><p>按印字原理划分，打印机分为打击式和非打击式</p><h3 id="5-2-4-其它外部设备"><a href="#5-2-4-其它外部设备" class="headerlink" title="5.2.4 其它外部设备"></a>5.2.4 其它外部设备</h3><p>A/D、D/A是模拟/数字、数字/模拟转换器的缩写</p><p>终端由键盘和显示器组成</p><p>终端能完成显示控制与存储、键盘管理及通信控制等功能</p><p>汉字处理设备包括：汉字输入、汉字储存和汉字输出三个部分</p><h3 id="5-2-5-多媒体技术"><a href="#5-2-5-多媒体技术" class="headerlink" title="5.2.5 多媒体技术"></a>5.2.5 多媒体技术</h3><p>视频和音频压缩与解压缩、多媒体芯片、大容量存储器、多媒体软件等各种核心计算机技术。</p><h2 id="5-3-I-O-接口"><a href="#5-3-I-O-接口" class="headerlink" title="5.3 I/O 接口"></a>5.3 I/O 接口</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>I/O 接口通常是指主机与外部设备之间设置的一个硬件电路及其相应的软件控制</p><p>为什么要设置接口？</p><ol><li><strong>实现设备的选择</strong></li><li><strong>实现数据缓冲达到速度匹配</strong></li><li><strong>实现数据串-并格式转换</strong></li><li><strong>实现电平转换</strong></li><li><strong>传送控制命令</strong></li><li><strong>反映设备的状态</strong>（忙、就绪、中断请求）</li></ol><p>端口是指接口电路中的一些寄存器，若干个端口加上相应的控制逻辑才能组成接口。</p><h3 id="5-3-2-接口的功能和组成"><a href="#5-3-2-接口的功能和组成" class="headerlink" title="5.3.2 接口的功能和组成"></a>5.3.2 接口的功能和组成</h3><h4 id="5-3-2-1-总线连接方式的I-O接口电路"><a href="#5-3-2-1-总线连接方式的I-O接口电路" class="headerlink" title="5.3.2.1 总线连接方式的I/O接口电路"></a>5.3.2.1 总线连接方式的I/O接口电路</h4><p>I/O 总线包括<strong>设备选择线</strong>、<strong>数据线</strong>、<strong>命令线</strong>和<strong>状态线</strong></p><p>数据线通常是双向的，用于传输数据代码</p><p>设备选择线通常是单向的，用于传输设备码，也可称为地址线</p><p>命令线和状态线是单向的</p><h4 id="5-3-2-2-接口的功能和组成"><a href="#5-3-2-2-接口的功能和组成" class="headerlink" title="5.3.2.2 接口的功能和组成"></a>5.3.2.2 接口的功能和组成</h4><p>接口通常有 4 个功能：<strong>选址</strong>、<strong>传送命令</strong>、<strong>传送数据</strong>、<strong>反应设备状态</strong></p><p>选址需要<strong>设备选择电路</strong></p><p>传送命令需要<strong>命令寄存器、命令译码器</strong></p><p>传送数据需<strong>数据缓冲寄存器DBR</strong></p><p>反映设备状态需要<strong>设备状态标记</strong></p><p>反映设备工作状态的触发器有：<strong>完成触发器D、工作触发器B、中断请求触发器INTR、屏蔽触发器MASK</strong></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618175454434.png" alt="image-20220618175454434"></p><h3 id="5-3-3-接口类型"><a href="#5-3-3-接口类型" class="headerlink" title="5.3.3 接口类型"></a>5.3.3 接口类型</h3><p>按数据传送方式分类：并行接口、串行接口</p><p>按功能选择的灵活性分类：可编程接口、不可编程接口</p><p>按通用性分类：通用接口、专用接口</p><p>按数据传送的控制方式分类：中断接口、DMA 接口</p><h2 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h2><h3 id="5-4-1-程序查询流程"><a href="#5-4-1-程序查询流程" class="headerlink" title="5.4.1 程序查询流程"></a>5.4.1 程序查询流程</h3><p>当 I/O 设备较多时 ， CPU 需按各个 I/O 设备在系统中的优先级别进行逐级查询</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618175816582.png" alt="image-20220618175816582"></p><p>通常要执行三条命令：测试指令、传送指令、转移指令</p><p>启动设备前的准备工作：保护寄存器原内容、设置设备与主机交换数据的计数值、设置欲传送数据在内存缓冲区的首地址</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618180536928.png" alt="image-20220618180536928"></p><p><strong>保存寄存器内容</strong>：内存与外设之间的数据输入输出需要借助CPU当中的某一个寄存器对数据进行暂存。如果这个寄存器中的原数据是后面程序需要使用的，就需要对这个数据进行保存，把该寄存器中的值写入到某一个内存单元中（压栈）或保存到其他闲置寄存器。</p><h3 id="5-4-2-程序查询方式的接口电路"><a href="#5-4-2-程序查询方式的接口电路" class="headerlink" title="5.4.2 程序查询方式的接口电路"></a>5.4.2 程序查询方式的接口电路</h3><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618215431062.png" alt="image-20220618215431062"></p><h2 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h2><h3 id="5-5-1-中断的概念"><a href="#5-5-1-中断的概念" class="headerlink" title="5.5.1 中断的概念"></a>5.5.1 中断的概念</h3><p>计算机在执行程序的过程中 ， 当出现异常情况或特殊请求时 ， 计算机停止现行程序的运行 ， 转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处 ， 这就是 “ 中断 ”。</p><p>中断源：人为设置的中断，程序异常（溢出、操作码不能识别、除法非法），硬件故障（磁表面损坏、电源掉电、插件接触不良），IO设备，外部事件（用键盘中断现行程序）</p><p>不可屏蔽中断：如电源掉电</p><p>可屏蔽中断：CPU可根据该中断源是否被屏蔽来确定是否给与响应</p><h3 id="5-5-2-I-O-中断的产生"><a href="#5-5-2-I-O-中断的产生" class="headerlink" title="5.5.2 I/O 中断的产生"></a>5.5.2 I/O 中断的产生</h3><p>计算机系统引入中断技术的原因不仅仅是为了适应 I/O 设备工作速度低的问题</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618221904470.png" alt="image-20220618221904470"></p><h3 id="5-5-3-程序中断方式的接口电路"><a href="#5-5-3-程序中断方式的接口电路" class="headerlink" title="5.5.3 程序中断方式的接口电路"></a>5.5.3 程序中断方式的接口电路</h3><h4 id="5-5-3-1-中断请求触发器和中断屏蔽触发器"><a href="#5-5-3-1-中断请求触发器和中断屏蔽触发器" class="headerlink" title="5.5.3.1 中断请求触发器和中断屏蔽触发器"></a>5.5.3.1 中断请求触发器和中断屏蔽触发器</h4><p>当完成触发器D为1且中断屏蔽触发器MASK为0时，收到CPU的中断查询信号后，中断请求触发器才会被设置为1</p><p>CPU 在执行每条指令的最后时刻査询所有的设备是否有中断请求 </p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618222447885.png" alt="image-20220618222447885"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618222512434.png" alt="image-20220618222512434"></p><h4 id="5-5-3-2-排队器"><a href="#5-5-3-2-排队器" class="headerlink" title="5.5.3.2 排队器"></a>5.5.3.2 排队器</h4><p>排队的两类办法：硬件和软件</p><p>排队器的硬件办法：链式排队器</p><p>链式排队器中，任意一个中断源提出请求后，比其优先级低的中断源都会被封锁</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618224638801.png" alt="image-20220618224638801"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618224955233.png" alt="image-20220618224955233"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618225037197.png" alt="image-20220618225037197"></p><h4 id="5-5-3-3-中断向量地址形成部件-（-设备编码器-）"><a href="#5-5-3-3-中断向量地址形成部件-（-设备编码器-）" class="headerlink" title="5.5.3.3 中断向量地址形成部件 （ 设备编码器 ）"></a>5.5.3.3 中断向量地址形成部件 （ 设备编码器 ）</h4><p>寻找入口地址的两种方法：软件查表、硬件向量法</p><p>由硬件产生向量地址，再由向量地址找到入口地址</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618225204652.png" alt="image-20220618225204652"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618225350592.png" alt="image-20220618225350592"></p><h4 id="5-5-3-4-程序中断方式接口电路的基本组成"><a href="#5-5-3-4-程序中断方式接口电路的基本组成" class="headerlink" title="5.5.3.4 程序中断方式接口电路的基本组成"></a>5.5.3.4 程序中断方式接口电路的基本组成</h4><p>中断发生时，程序计数器内容的保护和更新，是由硬件自动完成的。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618225617363.png" alt="image-20220618225617363"></p><h3 id="5-5-4-I-O-中断处理过程"><a href="#5-5-4-I-O-中断处理过程" class="headerlink" title="5.5.4 I/O 中断处理过程"></a>5.5.4 I/O 中断处理过程</h3><h4 id="5-5-4-1-CPU-响应中断的条件和时间"><a href="#5-5-4-1-CPU-响应中断的条件和时间" class="headerlink" title="5.5.4.1 CPU 响应中断的条件和时间"></a>5.5.4.1 CPU 响应中断的条件和时间</h4><p>条件：允许中断触发器 EINT = 1</p><p>用开中断指令将EINT置“1”，<em>用关中断指令将 EINT置“0”或硬件自动复位</em>  <strong>在中断响应周期，EINT置“0”由硬件自动完成</strong></p><p>时间：在每条指令执行阶段的结束前  (指令执行周期结束时刻由CPU 发查询信号)</p><p>当 D = 1（随机）且 MASK = 0 时，在每条指令执行阶段的结束前，CPU 发中断查询信号（将INTR置“1”）</p><p>在中断响应周期，置“0”允许中断触发器是由硬件自动完成的。</p><p><em>在某些计算机中，由于指令执行时间很长，需要在指令执行过程中设置若干个查询断点，CPU在每个“查询断点”时刻均发出中断查询信号，以便及时响应中断请求。</em></p><h4 id="5-5-4-2-中断隐指令"><a href="#5-5-4-2-中断隐指令" class="headerlink" title="5.5.4.2 中断隐指令"></a>5.5.4.2 中断隐指令</h4><p><strong>隐指令</strong>：机器指令系统没有的指令，它是CPU在中断周期内由<strong>硬件自动完成</strong>的一条指令。保护程序断点、寻找入口地址、关中断在中断周期内由一条隐指令完成。</p><p>（1）<strong>保护程序断点</strong></p><p>断点（程序计数器PC的内容）存于特定地址（0号地址）内</p><p>断点进栈</p><p>（2）<strong>寻找服务程序入口地址</strong></p><p>向量地址—&gt;PC （硬件向量法）</p><p>中断识别程序 入口地址 M—&gt;PC （软件查询法）</p><p>（3）<strong>硬件关中断</strong></p><p>INT 中断标记触发器，EINT 允许中断触发器，R – S 触发器</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618230858606.png" alt="image-20220618230858606"></p><h4 id="5-5-4-3-I-O中断处理过程"><a href="#5-5-4-3-I-O中断处理过程" class="headerlink" title="5.5.4.3 I/O中断处理过程"></a>5.5.4.3 I/O中断处理过程</h4><p>中断处理过程简单地归纳为中断请求、中断判优、中断响应、中断服务和中断返回五个阶段</p><p>中断方式一般用于处理随机出现的服务请求</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618231803590.png" alt="image-20220618231803590"></p><h3 id="5-5-5-中断服务程序流程"><a href="#5-5-5-中断服务程序流程" class="headerlink" title="5.5.5 中断服务程序流程"></a>5.5.5 中断服务程序流程</h3><h4 id="5-5-5-1-中断服务程序的流程"><a href="#5-5-5-1-中断服务程序的流程" class="headerlink" title="5.5.5.1 中断服务程序的流程"></a>5.5.5.1 中断服务程序的流程</h4><p>一般中断服务程序的流程分四大部分：<strong>保护现场</strong>、<strong>中断服务</strong>、<strong>恢复现场</strong>和<strong>中断返回</strong>。</p><h5 id="（1）保护现场"><a href="#（1）保护现场" class="headerlink" title="（1）保护现场"></a>（1）保护现场</h5><p>保护程序断点和通用寄存器内容</p><p>程序<strong>断点</strong>的保护由<strong>中断隐指令</strong>完成</p><p>通用寄存器和状态<strong>寄存器</strong>内容的保护由<strong>进栈指令</strong>（<strong>中断服务程序</strong>）完成</p><h5 id="（2）中断服务"><a href="#（2）中断服务" class="headerlink" title="（2）中断服务"></a>（2）中断服务</h5><p>对于不同 I/O 设备具有不同内容的设备服务（不同中断请求源，中断服务操作内容不同）</p><h5 id="（3）恢复现场"><a href="#（3）恢复现场" class="headerlink" title="（3）恢复现场"></a>（3）恢复现场</h5><p>通常可用<strong>取数/出栈指令</strong>恢复寄存器内容（将保存在<strong>存储器/堆栈</strong>中的信息送回原寄存器），由<strong>中断服务程序</strong>完成</p><h5 id="（4）中断返回"><a href="#（4）中断返回" class="headerlink" title="（4）中断返回"></a>（4）中断返回</h5><p>中断服务程序的最后一条指令通常是一条<strong>中断返回指令</strong>，返回原程序的断点处，继续执行原程序。</p><h4 id="5-5-5-2-单重中断和多重中断"><a href="#5-5-5-2-单重中断和多重中断" class="headerlink" title="5.5.5.2 单重中断和多重中断"></a>5.5.5.2 单重中断和多重中断</h4><p>单重中断不允许中断现行的中断服务程序，多重中断允许级别更高的中断源中断现行的中断服务程序</p><p>中断隐指令会关中断</p><p>单重中断与多重中断的主要区别是多重中断的服务程序中要提前开中断，而单重中断的服务程序中在最后中断返回之前才能开中断。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618233150802.png" alt="image-20220618233150802"></p><p>宏观上CPU和I/O并行工作，微观上CPU中断现行程序为I/O服务</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618233237713.png" alt="image-20220618233237713"></p><h3 id="5-5-6-中断屏蔽技术"><a href="#5-5-6-中断屏蔽技术" class="headerlink" title="5.5.6 中断屏蔽技术"></a>5.5.6 中断屏蔽技术</h3><h4 id="5-5-6-1-多重中断的概念"><a href="#5-5-6-1-多重中断的概念" class="headerlink" title="5.5.6.1 多重中断的概念"></a>5.5.6.1 多重中断的概念</h4><p>多重中断又称“中断嵌套”：CPU正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而CPU又响应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序。</p><h4 id="5-5-6-2-实现多重中断的条件"><a href="#5-5-6-2-实现多重中断的条件" class="headerlink" title="5.5.6.2 实现多重中断的条件"></a>5.5.6.2 实现多重中断的条件</h4><p>（1）提前设置开中断指令</p><p>（2）优先级别高的中断源 有权中断 优先级别低的中断源</p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618234125174.png" alt="image-20220618234125174" style="zoom:80%;"><h4 id="5-5-6-3-屏蔽技术"><a href="#5-5-6-3-屏蔽技术" class="headerlink" title="5.5.6.3 屏蔽技术"></a>5.5.6.3 屏蔽技术</h4><p>（1）屏蔽触发器的作用</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618234213182.png" alt="image-20220618234213182"></p><p>（2）屏蔽字</p><p>每个中断请求触发器都有一个中断屏蔽触发器，所有屏蔽触发器组合在一起便构成了一个屏蔽寄存器，屏蔽寄存器的内容称为屏蔽字。（屏蔽字对应中断源的优先级别）</p><p>（3）屏蔽技术可以改变处理优先等级</p><p>响应优先级：CPU响应各中断源请求的优先次序，一般是硬件电路已经设置好，<strong>不可改变</strong></p><p>处理优先级：CPU实际对各中断源请求的处理优先次序。<strong>可改变（通过重新设置屏蔽字）</strong></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618234947046.png" alt="image-20220618234947046" style="zoom:80%;"><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618235034038.png" alt="image-20220618235034038" style="zoom:80%;"></p><p>（4）屏蔽技术的其他作用</p><p>可以人为地屏蔽某个中断源的请求，便于程序控制</p><p>（5）新屏蔽字的设置：中断服务程序中设置新的屏蔽字</p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618235342578.png" alt="image-20220618235342578" style="zoom:80%;"><h2 id="5-6-DMA-方式"><a href="#5-6-DMA-方式" class="headerlink" title="5.6 DMA 方式"></a>5.6 DMA 方式</h2><h3 id="5-6-1-DMA-方式的特点"><a href="#5-6-1-DMA-方式的特点" class="headerlink" title="5.6.1 DMA 方式的特点"></a>5.6.1 DMA 方式的特点</h3><h4 id="5-6-1-1-DMA-和程序中断两种方式的数据通路"><a href="#5-6-1-1-DMA-和程序中断两种方式的数据通路" class="headerlink" title="5.6.1.1 DMA 和程序中断两种方式的数据通路"></a>5.6.1.1 DMA 和程序中断两种方式的数据通路</h4><p>DMA和程序中断在数据通路上的差别是：程序中断时，主存和设备交换信息需要通过 CPU，而 DMA 方式不需要。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220618235624616.png" alt="image-20220618235624616"></p><p>中断方式：</p><ul><li>传送一个数据执行一次中断服务子程序（几十条指令） </li><li>频繁占用CPU，效率低下</li><li>不适合于高速传输的系统</li></ul><p>DMA方式：</p><ul><li>外设与主存间建立一个由硬件管理的数据通路</li><li>CPU不介入外设与主存的数据传送操作</li><li>减少CPU开销，提升效率</li><li>适合成组交换数据的场合</li></ul><h4 id="5-6-1-2-DMA-与主存交换数据的三种方式"><a href="#5-6-1-2-DMA-与主存交换数据的三种方式" class="headerlink" title="5.6.1.2 DMA 与主存交换数据的三种方式"></a>5.6.1.2 DMA 与主存交换数据的三种方式</h4><p>DMA 与主存交换数据时的三种方法：停止CPU访问主存、周期挪用 （ 或周期窃取）、DMA 与 CPU 交替访问</p><p>（1）<strong>停止CPU访问主存</strong></p><p>当外设要求传送一批数据时，DMA接口向CPU发送一个停止信号，要求CPU放弃地址、数据和相关控制线的使用权；数据传送结束后，DMA接口通知CPU可以使用主存.</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619000420405.png" alt="image-20220619000420405"></p><p>优点：控制简单， 适用于数据传输率很高的 I/O 设备</p><p>缺点：DMA 接口在访存时，CPU 基本上处于不工作状态或保持原状态，未充分发挥 CPU 对主存的利用率</p><p>（2）<strong>DMA 与 CPU 交替访问</strong></p><p>将 CPU 工作周期(所有指令执行过程中的一个基准时间)分为两个分周期C1和C2，分别供 DMA 和 CPU 访存，适合于CPU的工作周期比主存存取周期长的情况。</p><p>DMA 与 CPU 交替访问方式不需要申请建立和归还总线的使用权，总线使用权由C1和C2控制。</p><p>CPU和DMA接口各自有独立的访存地址寄存器、数据寄存器、读/写信号。总线控制权的转移几乎不需要时间，DMA传送速率高。硬件逻辑比较复杂。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619000949623.png" alt="image-20220619000949623"></p><p>（3）<strong>周期挪用（周期窃取）</strong></p><p>DMA 访问主存有三种情况：</p><ul><li><p>CPU 此时不访存</p></li><li><p>CPU 正在访存：等待CPU存取周期结束，让出总线</p></li><li><p>CPU 和 DMA 同时请求访存：此时CPU将总线控制权让给DMA</p></li></ul><p>DMA方式中，周期窃取是窃取一个存取周期</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619001252623.png" alt="image-20220619001252623"></p><h3 id="5-6-2-DMA-接口的功能和组成"><a href="#5-6-2-DMA-接口的功能和组成" class="headerlink" title="5.6.2 DMA 接口的功能和组成"></a>5.6.2 DMA 接口的功能和组成</h3><h4 id="5-6-2-1-DMA-接口功能"><a href="#5-6-2-1-DMA-接口功能" class="headerlink" title="5.6.2.1 DMA 接口功能"></a>5.6.2.1 DMA 接口功能</h4><p>有以下五项功能：</p><ol><li><strong>向 CPU 申请 DMA 传送</strong></li><li><strong>处理总线控制权的转交</strong>（避免因进入DMA工作而影响CPU正常活动或者引起总线竞争）</li><li><strong>管理系统总线，控制数据传送</strong> </li><li><strong>确定数据传送的首地址和数据长度</strong>，更新数据传送过程中的数据地址和长度 </li><li>数据块传送（DMA传送）结束时，<strong>给出 DMA 操作完成的信号</strong> </li></ol><h4 id="5-6-2-2-DMA-接口组成"><a href="#5-6-2-2-DMA-接口组成" class="headerlink" title="5.6.2.2 DMA 接口组成"></a>5.6.2.2 DMA 接口组成</h4><p>最简单的 DMA 接口组成有以下几个逻辑部件：<strong>主存地址寄存器 AR</strong>、<strong>字计数器 WC</strong>、<strong>数据缓冲寄存器 BR</strong>、<strong>DMA 控制逻辑</strong>、<strong>中断机构</strong>、<strong>设备地址寄存器 DAR</strong></p><p>AR 用于存放主存中需要交换数据的地址</p><p>WC 用于记录传送数据的总字数，通常以交换字数的补码值预置</p><p>BR 用于暂存每次传送的数据</p><p>DMA 方式的接口电路中有程序中断部件，其作用是向CPU提出传输结束</p><p>DAR 存放 I/O 设备的设备码或表示设备信息存储区的寻址信息</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619001919576.png" alt="image-20220619001919576"></p><h3 id="5-6-3-DMA-的工作过程"><a href="#5-6-3-DMA-的工作过程" class="headerlink" title="5.6.3 DMA 的工作过程"></a>5.6.3 DMA 的工作过程</h3><h4 id="5-6-3-1-DMA-传送过程"><a href="#5-6-3-1-DMA-传送过程" class="headerlink" title="5.6.3.1 DMA 传送过程"></a>5.6.3.1 DMA 传送过程</h4><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619002600347.png" alt="image-20220619002600347"></p><p>包括三个阶段：<strong>预处理</strong>、<strong>数据传送</strong>、<strong>后处理</strong></p><h5 id="（1）预处理"><a href="#（1）预处理" class="headerlink" title="（1）预处理"></a>（1）预处理</h5><p>预处理阶段，CPU 需要设定 DMA 的传送方向、设备地址、主存地址、传送字数。通过几条输入输出指令（主机发送给DMA接口）预置如下信息：</p><ul><li>通知DMA控制逻辑传送方向（入/出）</li><li>设备地址—&gt;DMA的DAR</li><li>主存地址—&gt;DMA的AR</li><li>传送字数—&gt;DMA的WC</li></ul><h5 id="（2）数据传送"><a href="#（2）数据传送" class="headerlink" title="（2）数据传送"></a>（2）数据传送</h5><p>数据输入时，在数据传送阶段，第一步，DMA 的 BR 将从设备读入。第二步，设备向 DMA 接口发请求 DREQ。第三步，DMA 接口向 CPU 申请总线控制权 HRQ。第四步，CPU 发回 HLDA 信号，表示允许转交总线控制权。第五步， AR 送地址总线。第六步，通知设备已被授予一个 DMA 周期 DACK。第七步，将 BR 送数据总线。第八步，修改 AR 和 WC。第九步，判断传送是否结束。如果结束，将向 CPU 申请程序中断。</p><p>DMA方式是以数据块为单位传送的。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619011740317.png" alt="image-20220619011740317"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619011754123.png" alt="image-20220619011754123"></p><h5 id="（3）后处理"><a href="#（3）后处理" class="headerlink" title="（3）后处理"></a>（3）后处理</h5><p>当DMA的中断请求得到响应后，CPU停止执行原程序，转去执行中断服务程序，做一些DMA的结束工作，包括：</p><ul><li>校验送入主存的数是否正确</li><li>是否继续用DMA</li><li>测试传送过程是否正确，错则转诊断程序</li></ul><p>后处理由<strong>中断服务程序</strong>完成</p><h4 id="5-6-3-2-DMA-接口与系统的连接方式"><a href="#5-6-3-2-DMA-接口与系统的连接方式" class="headerlink" title="5.6.3.2 DMA 接口与系统的连接方式"></a>5.6.3.2 DMA 接口与系统的连接方式</h4><p>0</p><p>DMA 接口与系统的连接方式有两种：有公共请求线请求和独立请求</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619013530310.png" alt="image-20220619013530310"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619013543347.png" alt="image-20220619013543347"></p><h4 id="5-6-3-3-DMA-方式与程序中断方式的比较"><a href="#5-6-3-3-DMA-方式与程序中断方式的比较" class="headerlink" title="5.6.3.3 DMA 方式与程序中断方式的比较"></a>5.6.3.3 DMA 方式与程序中断方式的比较</h4><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619013607941.png" alt="image-20220619013607941"></p><p>从数据传送看，程序中断方式靠程序传送， DMA 方式靠硬件传送 </p><p>从 CPU 响应时间看 ， 程序中断方式是在一条指令执行结束时响应，而 DMA 方式可在指令周期内的任一存取周期结束时响应 </p><p>程序中断方式有处理异常事件的能力 ， DMA 方式没有这种能力</p><p>程序中断方式的中断请求用于传送数据，DMA 的中断请求用于后处理</p><p>DMA 的优先级比程序中断高 </p><h3 id="5-6-4-DMA-接口的类型"><a href="#5-6-4-DMA-接口的类型" class="headerlink" title="5.6.4 DMA 接口的类型"></a>5.6.4 DMA 接口的类型</h3><h4 id="5-6-4-1-选择型-DMA-接口"><a href="#5-6-4-1-选择型-DMA-接口" class="headerlink" title="5.6.4.1 选择型 DMA 接口"></a>5.6.4.1 选择型 DMA 接口</h4><p>在物理上连接多个设备，在逻辑上只允许连接一个设备</p><p>选择型 DMA 接口特别适用于数据传输率很高的设备</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619014055548.png" alt="image-20220619014055548"></p><h4 id="5-6-4-2-多路型-DMA-接口"><a href="#5-6-4-2-多路型-DMA-接口" class="headerlink" title="5.6.4.2 多路型 DMA 接口"></a>5.6.4.2 多路型 DMA 接口</h4><p>多路型 DMA 接口适合于同时为多个数据传输率不十分高的设备服务，多路型 DMA 接口分为链式多路和独立请求多路，速度高的设备优先级高。</p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619014121467.png" alt="image-20220619014121467"></p><p><img src="/2022/06/27/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220619014241624.png" alt="image-20220619014241624"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/27/hello-world/"/>
    <url>/2022/06/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
